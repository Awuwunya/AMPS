<!DOCTYPE HTML>
<html>
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>AMPS v2.0 TECHNICAL DOCUMENTATION</title>
	<script>
		const chantbl = [
			{ size: 1, align: 1, name: "cFlags", },
			{ size: 1, align: 1, name: "cType", },
			{ size: 4, align: 2, name: "cData", },
			{ size: 0, align: 1, name: "cEnvPos", cno: 0x10, },
			{ size: 0, align: 1, name: "cStatPSG4", cyes: 0x10, },
			{ size: 1, align: 1, name: "cPanning", },
			{ size: 1, align: 1, name: "cDetune", },
			{ size: 1, align: 1, name: "cPitch", },
			{ size: 1, align: 1, name: "cVolume", },
			{ size: 1, align: 1, name: "cTick", },
			{ size: 0, align: 1, name: "cVolEnv", cno: 0x10, },
			{ size: 0, align: 1, name: "cSample", },
			{ size: 1, align: 1, name: "cVoice", },
			{ size: 1, align: 1, name: "cDuration", },
			{ size: 1, align: 1, name: "cLastDur", },
			{ size: 2, align: 2, name: "cFreq", },

			{ size: 0, align: 2, cyes: 0x02, name: "cModDelay", },
			{ size: 4, align: 2, cyes: 0x02, name: "cMod", },
			{ size: 2, align: 2, cyes: 0x02, name: "cModFreq", },
			{ size: 1, align: 1, cyes: 0x02, name: "cModSpeed", },
			{ size: 1, align: 1, cyes: 0x02, name: "cModStep", },
			{ size: 1, align: 1, cyes: 0x02, name: "cModCount", },

			{ size: 1, align: 1, cyes: 0x04, name: "cPortaSpeed", },
			{ size: 2, align: 2, cyes: 0x04, name: "cPortaFreq", },
			{ size: 2, align: 2, cyes: 0x04, name: "cPortaDisp", },

			{ size: 1, align: 1, cyes: 0x10, name: "cVolEnv", },
			{ size: 1, align: 1, cyes: 0x10, name: "cEnvPos", },

			{ size: 1, align: 1, cyes: 0x08, name: "cModEnv", },
			{ size: 1, align: 1, cyes: 0x08, name: "cModEnvPos", },
			{ size: 1, align: 1, cyes: 0x08, name: "cModEnvSens", },

			{ size: 3, align: 1, name: "cLoop", },
			{ size: 1, align: 2, name: "cStatPSG4", offset: -2, cno: 0x10, },
			{ size: 1, align: 2, name: "cPrio", offset: -1, },
			{ size: 0, align: 2, name: "cSizeSFX", save: -2, },

			{ size: 1, align: 1, name: "cGateCur", },
			{ size: 1, align: 1, name: "cGateMain", },
			{ size: 1, align: 1, name: "cStack", },
			{ size:12, align: 2, name: "", },
			{ size: 0, align: 2, name: "cSize", save: -1, },
		];

		const ramtbl = [
			{ size: 1, align: 1, name: "mFlags", },
			{ size: 1, align: 1, name: "mCtrPal", },
			{ size: 8, align: 1, name: "mComm", },
			{ size: 0, align: 2, name: "mMasterVolFM", },
			{ size: 4, align: 2, name: "mFadeAddr", },
			{ size: 1, align: 1, name: "mTempoMain", },
			{ size: 1, align: 1, name: "mTempoSpeed", },
			{ size: 1, align: 1, name: "mTempo", },
			{ size: 1, align: 1, name: "mTempoCur", },
			{ size: 3, align: 1, name: "mQueue", },
			{ size: 1, align: 1, name: "mMasterVolPSG", },
			{ size: 4, align: 2, name: "mVctMus", },
			{ size: 1, align: 1, name: "mMasterVolDAC", },
			{ size: 1, align: 1, name: "mSpindash", },
			{ size: 1, align: 1, name: "mContCtr", },
			{ size: 1, align: 1, name: "mContLast", },
			{ size: 1, align: 1, name: "mLastCue", },

			{ size: 0,  align: 2, name: "mBackUpArea", },
			{ size: -1, align: 2, name: "mDAC1", },
			{ size: -1, align: 2, name: "mDAC2", },
			{ size: -1, align: 2, name: "mFM1", },
			{ size: -1, align: 2, name: "mFM2", },
			{ size: -1, align: 2, name: "mFM3", },
			{ size: -1, align: 2, name: "mFM4", },
			{ size: -1, align: 2, name: "mFM5", },
			{ size: -1, align: 2, name: "mFM6", cyes: 0x40, },
			{ size: -1, align: 2, name: "mPSG1", },
			{ size: -1, align: 2, name: "mPSG2", },
			{ size: -1, align: 2, name: "mPSG3", },

			{ size: -2, align: 2, name: "mSFXDAC1", },
			{ size: -2, align: 2, name: "mSFXFM3", },
			{ size: -2, align: 2, name: "mSFXFM4", },
			{ size: -2, align: 2, name: "mSFXFM5", },
			{ size: -2, align: 2, name: "mSFXPSG1", },
			{ size: -2, align: 2, name: "mSFXPSG2", },
			{ size: -2, align: 2, name: "mSFXPSG3", },
			{ size: 0,  align: 2, name: "mChannelEnd", },

			{ size: 0,  align: 2, cyes: 0x20, name: "mBackUpLoc", },
			{ size: -1, align: 2, cyes: 0x20, name: "mBackDAC1", },
			{ size: -1, align: 2, cyes: 0x20, name: "mBackDAC2", },
			{ size: -1, align: 2, cyes: 0x20, name: "mBackFM1", },
			{ size: -1, align: 2, cyes: 0x20, name: "mBackFM2", },
			{ size: -1, align: 2, cyes: 0x20, name: "mBackFM3", },
			{ size: -1, align: 2, cyes: 0x20, name: "mBackFM4", },
			{ size: -1, align: 2, cyes: 0x20, name: "mBackFM5", },
			{ size: -1, align: 2, cyes: 0x60, name: "mBackFM6", },
			{ size: -1, align: 2, cyes: 0x20, name: "mBackPSG1", },
			{ size: -1, align: 2, cyes: 0x20, name: "mBackPSG2", },
			{ size: -1, align: 2, cyes: 0x20, name: "mBackPSG3", },

			{ size: 1, align: 1, cyes: 0x20, name: "mBackTempoMain", },
			{ size: 1, align: 1, cyes: 0x20, name: "mBackTempoSpeed", },
			{ size: 1, align: 1, cyes: 0x20, name: "mBackTempo", },
			{ size: 1, align: 1, cyes: 0x20, name: "mBackTempoCur", },
			{ size: 4, align: 2, cyes: 0x20, name: "mBackVctMus", },

			{ size: 1, align: 1, cyes: 0x01, name: "msChktracker", },
			{ size: 0, align: 2, name: "mSize", },
		];

		var sizes = Array(2), mode = 0;

		function refRAM() {
			mode = document.getElementById("mdsafe").checked * 0x01;
			mode |= document.getElementById("mdmod").checked * 0x02;
			mode |= document.getElementById("mdport").checked * 0x04;
			mode |= document.getElementById("mdmenv").checked * 0x08;
			mode |= document.getElementById("mdvenvdf").checked * 0x10;
			mode |= document.getElementById("mdbackup").checked * 0x20;
			mode |= document.getElementById("mdfm6").checked * 0x40;

			let def = `
				<tr>
					<td>offset</td><td>length</td><td>equate</td>
				</tr>
			`;

			document.getElementById("chantable").innerHTML = def + procRAM(chantbl);
			document.getElementById("ramtable").innerHTML = def + procRAM(ramtbl);
		}

		function procRAM(tbl) {
			let data = "", pos = 0;

			for(e of tbl) {
				if(e.cyes && (mode & e.cyes) != e.cyes)
					continue;

				if(e.cno && (mode & e.cno) != 0)
					continue;

				if(e.align && pos % e.align != 0){
					pos += e.align - (pos % e.align);
				}

				let s = e.size >= 0 ? e.size : sizes[-1 - e.size];

				if(e.offset){
					data += "<tr><td>"+ hexstr(pos + e.offset, 4) +"</td><td>"+ hexstr(s, 2) +"</td><td>"+ e.name +"</td>";

				} else {
					data += "<tr><td>"+ hexstr(pos, 4) +"</td><td>"+ hexstr(s, 2) +"</td><td>"+ e.name +"</td>";
					pos += s;
				}

				if(e.save) {
					sizes[-1 - e.save] = pos;
				}
			}

			return data;
		}

		function hexstr(num, len) {
			num = num.toString(16).toUpperCase();
			return "$" + ("0".repeat(len - num.length)) + num;
		}

		function tmpc(e){
			let a = document.getElementById(e).value;
			if(a !== a || a == undefined) return;

			a.startsWith("$") && (a = a.substring(1));
			a.startsWith("0x") && (a = a.substring(2));
			a = parseInt(a, 16);
			if(a !== a || a == undefined) return;

			if(e == "tmsh2") a = (-a) & 0xFF;

			let n = ((a == 0) << 8) | a;
			n = ((((n - 1) << 8) + (n >> 1)) / n) & 0xFF;
			n = (0x100 - ((n == 0) | n)) & 0xFF;

			if(e == "tmctr") {
				let x = a;
				a = n;
				n = x;
			}

			document.getElementById("tmctr").value = n.toString(16).toUpperCase();
			document.getElementById("tmsh2").value = ((-a) & 0xFF).toString(16).toUpperCase();
			document.getElementById("tmofw").value = a.toString(16).toUpperCase();
		}
	</script>
	<link href="https://fonts.googleapis.com/css?family=Noto+Sans&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Rubik:400,700&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Overpass:400,700&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono&display=swap" rel="stylesheet">
	<style>
		html {
			background: black;
			color: #C2C2C2;
			padding: 1vh 2vw;
		}

		body {
			background: #232323;
			border: .16vw solid gray;
			border-radius: 2vw;
			margin: auto;
			padding: 2vw;
		}

		.bd {
			border-top: .3vw solid;
			border-image: linear-gradient(to right, rgba(94,90,133,0.03) 0%, rgba(92,92,104,1) 20%, rgba(92,92,104,1) 80%, rgba(94,90,133,0.03) 100%) 1 round;
		}

		h1 {
			font: 2.8vw 'Noto Sans', sans-serif;
			margin: 1.2vw 0;
		}

		h3 {
			font: 2vw 'Noto Sans', sans-serif;
			margin: 1vw 0;
		}

		h4 {
			font: 1.4vw 'Noto Sans', sans-serif;
			margin: 1vw 0;
			font-weight: bold;
		}

		p {
			font: 1vw 'Rubik', sans-serif;
			margin: .3vw 1.2vw .8vw 0;
		}

		p > a, li > a {
			color: #cbacb0;
			text-decoration: none;
		}

		tblcnt {
			font: 1.1vw 'Rubik', sans-serif;
			display: block;
			white-space: pre;
		}

		tblcnt > a {
			color: #C2C2C2;
			text-decoration: none;
		}

		tblcnt > a:focus, tblcnt > a:hover, p > a:focus, p > a:hover, li > a:focus, li > a:hover {
			text-decoration: underline;
		}

		tblcnt > a:active {
			color: #ffffff;
			text-decoration: underline;
		}

		p > a:active, li > a:active {
			color: #b57e79;
			text-decoration: underline;
		}

		li {
			font: 1.1vw 'Overpass', sans-serif;
			margin: 0 1.5vw 0 0;
		}

		li > b {
			color: #c67431;
		}

		table {
			font: .95vw 'Roboto Mono', sans-serif;
			margin: 0 .5vw;
			border-collapse: collapse;
			text-align: center;

			overflow-x: auto;
			max-width: 100%;
			width: fit-content;
			display: block;
			position: relative;
		}

		td {
			padding: .24vw .24vw;
			border: .1vw solid whitesmoke;
		}

		cbox {
			display: inline-block;
			margin: .3vw;
			white-space: nowrap;
		}

		cbox > input[type=checkbox] {
			margin: 0;
			vertical-align: middle;
			-webkit-appearance: none;
			width: 1vw;
			height: 1vw;
			display: inline-block;
			position: relative;
			background: #1e1e1e;
			border: .1vw solid #545454;
			padding: .4vw;
			border-radius: 20%;
			outline: none !important;
		}

		cbox > input[type=checkbox]:active, cbox > input[type=checkbox]:checked:active,
		cbox > input[type=checkbox]:focus, cbox > input[type=checkbox]:checked:focus,
		cbox > input[type=checkbox]:hover, cbox > input[type=checkbox]:checked:hover {
			background: #393939;
		}

		cbox > input[type=checkbox]:checked {
			background: #000000;
		}

		cbox > input[type=checkbox]:checked:after {
			content: '\2714';
			font: 1vw 'Roboto Mono', sans-serif;
			position: absolute;
			top: -.35vw;
			left: 0;
			color: #b5bfc6;
			font-weight: bold;
		}

		cbox > input[type=checkbox]::after {
			outline: none !important;
		}

		cbox > span {
			font: 1.2vw 'Overpass', sans-serif;
			margin-left: .1vw;
			vertical-align: middle;
		}

		input {
			background: #1e1e1e;
			border-color: #5c585b;
			color: whitesmoke;
			font: 1vw 'Roboto Mono', monospace;
		}

		input:focus, input:active {
			background: #2e2e2e;
		}

		button {
			background: #1e1e1e;
			color: whitesmoke;
			border: .1vw solid #5c585b;
			font: .8vw 'Overpass', sans-serif;
		}

		button:focus, button:active {
			background: #2e2e2e;
		}

		smps2asm, asm {
			display: block;
			overflow-x: auto;
			tab-size: 8;
			white-space: pre;
			background: #272823;
			font: .9vw 'Roboto Mono', monospace;
			border: .1vw solid rgba(255,255,255,.3);
			margin: .1vw .4vw;
			padding: .4vw .5vw;
		}

		smps2asm::-moz-selection, smps2asm > *::-moz-selection, asm::-moz-selection, asm > *::-moz-selection {
			background: #606080CF;
		}

		smps2asm::selection, smps2asm > *::selection, asm::selection, asm > *::selection {
			background: #606080CF;
		}

		smps2asm > lbl, asm > lbl {
			color: #D4D4D4;
		}

		smps2asm > mac, asm > mac {
			color: #4CBD00;
		}

		smps2asm > val, asm > val {
			color: #FF7575;
		}

		smps2asm > equ, asm > equ {
			color: #AA7FFF;
		}

		smps2asm > cmt, asm > cmt {
			color: #8F8F8F;
		}

		smps2asm > opc, asm > opc {
			color: #9fb6f2;
		}

		asm > ea {
			color: #4EB51B;
		}

		asm > math {
			color: #FFC273;
		}

		@media screen and (max-width: 800px){
			body {
				border: .2vw solid gray;
				border-radius: 2.2vw;
			}

			tblcnt {
				font-size: 1.8vw;
			}

			h1 {
				font-size: 4vw;
			}

			h3 {
				font-size: 3.2vw;
			}

			h4 {
				font-size: 2.4vw;
			}

			p {
				font-size: 1.8vw;
			}

			ul {
				margin-top: .4vw;
				margin-bottom: .6vw;
			}

			li {
				font-size: 1.7vw;
				margin: 0 1.7vw 0 0;
			}

			table {
				font-size: 1.5vw;
				border-width: .15vw;
				margin: .7vw .1vw 1vw;
			}

			td {
				padding: .3vw .4vw;
			}

			cbox > input[type=checkbox] {
				width: 1.8vw;
				height: 1.8vw;
				border-width: .2vw;
				padding: .8vw;
			}

			cbox > input[type=checkbox]:checked:after {
				font-size: 1.6vw;
				top: -.3vw;
			}

			cbox > span {
				font-size: 1.8vw;
			}

			input {
				font: 1.7vw 'Roboto Mono', monospace;
			}

			button {
				border: .15vw solid #5c585b;
				font: 1.4vw 'Overpass', sans-serif;
			}

			smps2asm, asm {
				font-size: 1.5vw;
				border-width: .2vw;
				margin: .1vw .5vw;
				padding: .3vw .4vw;
			}
		}

		@media screen and (max-width: 600px){
			body {
				border: .2vw solid gray;
				border-radius: 0;
				padding: 1vw;
			}

			tblcnt {
				font-size: 2vw;
			}

			.bd {
				border-top: .4vw solid;
			}

			h1 {
				font-size: 5vw;
				margin: 1.8vw 0;
			}

			h3 {
				font-size: 3.8vw;
				margin: 1.5vw 0;
			}

			h4 {
				font-size: 2.8vw;
				margin: 1.5vw 0;
			}

			p {
				font-size: 2.4vw;
				margin: .5vw 1.6vw 1vw 0;
			}

			ul {
				margin-top: 1vw;
				margin-bottom: 1vw;
			}

			li {
				font-size: 2.25vw;
				margin: 0 1.9vw 0 0;
			}

			table {
				font-size: 1.9vw;
				margin: 1vw .1vw 1.5vw;
				border-width: .2vw;
			}

			td {
				padding: .5vw .6vw;
			}

			cbox {
				margin: .5vw;
			}

			cbox > input[type=checkbox] {
				width: 3vw;
				height: 3vw;
				border-width: .28vw;
				padding: 1vw;
			}

			cbox > input[type=checkbox]:checked:after {
				font-size: 2.5vw;
				top: -.6vw;
			}

			cbox > span {
				font-size: 2.4vw;
				margin-left: .4vw;
			}

			input {
				font: 2.5vw 'Roboto Mono', monospace;
			}

			button {
				border: .2vw solid #5c585b;
				font: 2vw 'Overpass', sans-serif;
			}

			smps2asm, asm {
				font-size: 1.8vw;
				border-width: .3vw;
				margin: 0 .4vw;
				padding: .4vw .2vw;
			}
		}
	</style>
</head>
<body onload="refRAM();">
	<h3 style='text-decoration: underline;'>AMPS v2.0 technical manual</h3>
	<h1>Table of contents</h1>
	<tblcnt><a href="#part1">1 — Introduction</a></tblcnt>
	<tblcnt><a href="#part1_1">	1.1 — Undefined Behaviour</a></tblcnt>
	<tblcnt><a href="#part2">2 — AMPS Overview</a></tblcnt>
	<tblcnt><a href="#part3">3 — Sound System</a></tblcnt>
	<tblcnt><a href="#part3_1">	3.1 — Music Files</a></tblcnt>
	<tblcnt><a href="#part3_2">	3.2 — Sound Effect Files</a></tblcnt>
	<tblcnt><a href="#part4">4 — Trackers</a></tblcnt>
	<tblcnt><a href="#part4_1">	4.1 — Trackers Overview</a></tblcnt>
	<tblcnt><a href="#part4_2">	4.2 — Tracker Commands</a></tblcnt>
	<tblcnt><a href="#part4_3">	4.3 — SN76496</a></tblcnt>
	<tblcnt><a href="#part4_4">	4.4 — YM2612</a></tblcnt>
	<tblcnt><a href="#part4_5">	4.5 — Dual PCM</a></tblcnt>
	<tblcnt><a href="#part5">5 — Frequency</a></tblcnt>
	<tblcnt><a href="#part5_1">	5.1 — Modulation</a></tblcnt>
	<tblcnt><a href="#part6">6 — Volume</a></tblcnt>
	<tblcnt><a href="#part6_1">	6.1 — Channel Volumes</a></tblcnt>
	<tblcnt><a href="#part6_2">	6.2 — Underwater mode</a></tblcnt>
	<tblcnt><a href="#part6_3">	6.3 — Volume Fading</a></tblcnt>
	<tblcnt><a href="#part7">7 — Envelopes</a></tblcnt>
	<tblcnt><a href="#part8">8 — Communication Bytes</a></tblcnt>
	<tblcnt><a href="#part9">9 — Memory Map</a></tblcnt>
	<tblcnt><a href="#part10">10 — Creating Custom Music</a></tblcnt>
	<tblcnt><a href="#part11">11 — Porting Music</a></tblcnt>
	<tblcnt><a href="#part12">12 — Installing AMPS</a></tblcnt>
	<tblcnt><a href="#part13">13 — Frequent Questions & Answers</a></tblcnt>

	<h1 id="part1" class="bd">1 — Introduction</h1>
	<p>
		AMPS is a 68k-based, SMPS-like sound driver, designed to be used with ROM hacks and Sega Mega Drive software.
		Although similar to SMPS, AMPS is fundamentally different in many aspects. It is also heavily customized, RAM-efficient
		and cycle-efficient. AMPS is additionally powered by Dual PCM FlexEd, meaning that you can use 2 DAC sample channels
		with pitch and volume control. AMPS was designed to be a well-documented driver with a lot of capabilities so that
		the music created for the sound driver can sound better, and the music and game program can interact with each other.
		To ensure this, AMPS has a very robust codebase built to allow future expansion and customized programming for
		game-specific circumstances.
	</p>
	<p>
		AMPS is open source and free to use, given that you follow the license. You can easily make your own modifications, do feature
		requests, and make some great music. Currently, there is a limited number of options to create music, but using tools designed
		for other sound drivers, you can convert the files into AMPS format. More on that in <a href="#part9">part 9</a>.
	</p>

	<h3 id="part1_1" class="bd">1.1 — Undefined Behaviour</h3>
	<p>
		This document will talk a lot about undefined behaviour. But what is undefined behaviour? Simply, undefined behaviour is things that you can do from a technical sense, and there is
		nothing stopping you, but it is not intended to be done and therefore the result can be whatever. It can change, or stay the same, depend on something, and change between versions.
		While it is possible to do, you really shouldn't. It is never guaranteed to work the way you expect, want, or desire. Furthermore, trying to support someone's preferences of things
		that weren't ever supposed to exist is not possible, and I won't waste my time trying. In the future, safe mode will be more careful about checking for undefined behaviour, but right
		now often that is not the case.
	</p>

	<h1 id="part2" class="bd">2 — AMPS Overview</h1>
	<p>
		AMPS is based on sound data files, perhaps erroneously referred to as tracker files. These files define each song and sound effect
		you may hear in a game. They do not specify samples themselves, as those are handled by a different system. They are
		the backbone of AMPS and without them no sound would be generated. Tracker files tell AMPS what notes to play, how long to
		play them, and can also tell AMPS about other aspects of how hardware should act. For example, you can manipulate
		<a href="#part4_4">YM2612</a> registers or tell <a href="#part4_5">Dual PCM</a> how to play samples. Additionally, AMPS has
		a long list of built-in features that help the programmer to make cool effects without needing to have in-depth programming
		ability.
	</p>
	<p>
		AMPS includes a number of customizable flags, that allow the programmer to decide which features they are going to need for
		their project. The more flags are enabled, generally, the more system RAM and processor cycles are required to execute AMPS,
		though there are also exceptions. Here is a list of currently available flags:
	</p>
	<ul>
		<li><b>FEATURE_SAFE_PSGFREQ</b> — When enabled, the PSG frequency behaviour is set to safe mode. When disabled,
			it is possible that a PSG frequency overflows and messes with other PSG channels. This behaviour, for whatever reason,
			is required to make the insta-shield sound effect from Sonic 3 & Knuckles work correctly.</li>
		<li><b>FEATURE_SFX_MASTERVOL</b> — When enabled, sound effect channels will be affected by <a href="#part6">master volume.</a></li>
		<li><b>FEATURE_MODULATION</b> — When enabled, <a href="#part5_1">software modulation</a> can be used. This allows
			the programmer to define a linear change for frequency over time, which can also go back and forth between
			rising and falling.</li>
		<li><b>FEATURE_PORTAMENTO</b> — When enabled, <a href="#part5_2">the portamento command</a> can be used. Portamento
			makes the notes smoothly change over specified number of frames (or 0 frames which disables this effect).</li>
		<li><b>FEATURE_MODENV</b> — When enabled, <a href="#part5">modulation envelopes</a> can be used. Similarly to
			volume envelopes (also known as PSG instruments or PSG tones), they can be used to create more complex patterns
			for changing channel frequency. Every frame a value is read from a list specified by the modulation envelope ID,
			and that is used to calculate the frequency displacement.</li>
		<li><b>FEATURE_DACFMVOLENV</b> — When enabled, <a href="#part6_1">volume envelopes</a> can be used in DAC and FM
			channels along with PSG channels. They can be used to create more complex patterns for changing channel volume.
			Every frame a value is read from a list specified by the volume envelope ID, which is then used to calculate the
			volume displacement.</li>
		<li><b>FEATURE_UNDERWATER</b> — When enabled, <a href="#part6_2">underwater mode</a> is enabled. This makes it so that
			68k can request underwater mode to be activated, and when it is, all FM voices will sound slightly muffled. This is intended
			to emulate how music would sound if it were played underwater. Although the effect is not perfect, it creates an
			additional "depth" to how your game will sound when implemented right.</li>
		<li><b>FEATURE_BACKUP</b> — When enabled, music can be <a href="#part4_2">"backed up"</a> so it can be later started from
			the same place. This is useful if you have a temporary song you want to play for a small moment, but don't want the
			previous song to start from the beginning again. In Sonic games this is commonly used for the 1-UP sound. The one big downside of
			this flag is that it requires nearly double the amount of RAM as the driver regularly needs.</li>
		<li><b>FEATURE_BACKUPNOSFX</b> — When enabled, this prevents sound effects from playing when a song is backed up.</li>
		<li><b>FEATURE_FM6</b> — When enabled, FM6 can be used as a music channel in addition to DAC1 and DAC2 as sample channels.
			Because FM6 and DAC cannot play at the same time, whenever <b>any</b> DAC is playing in any channel, FM6 is temporarily
			disabled. FM6 keeps playing as normal in the background, but no sound is output. This feature is useful when you want
			to use FM6 for any song, but still want to have access to DAC channels too.</li>
	</ul>
	<p>
		AMPS also uses additional data, such as volume and modulation envelope data, sample tables, and other miscellaneous
		include files. This data is all defined in the <b>code/Data.asm</b> file, which is the file you will be editing most.
		Additionally, <b>AMPS Includer.exe</b> is used to pre-process this file so it works correctly in both ASM68K and AS. There
		are also a number of customizable things, such as volume fades, frequency tables, and PCM volume filters.
	</p>

	<h1 id="part3" class="bd">3 — Sound System</h1>
	<p>
		AMPS uses sound IDs to differentiate each sound. There can be at most 255 sounds (from $01 to $FF), and they are split into 3 main
		groups: Commands, music, and sound effects. All of these have different behaviors, for a very specific reason: sound effect
		channels override music channels, due to a lack of hardware channels. Effectively, sound effects have to correctly inform music that a channel is
		in use, and therefore has to be differentiated. By default, commands come first, then music, and finally sound effects. There is no specific
		reason for this, other than making the organisation easier. Below is a list of sound commands:
	</p>
	<ul>
		<li><b>mus_Reset</b> — Resets various things about AMPS: the underwater mode, speed shoes mode, and any backed-up song status.</li>
		<li><b>mus_FadeOut</b> — Fades out the current song.</li>
		<li><b>mus_Stop</b> — Stops the current song and sound effects immediately. Also clears sound driver memory and mutes hardware.</li>
		<li><b>mus_ShoesOn</b> — Enables the speed shoes mode. This changes the tempo from using normal tempo, to the speed up tempo defined for the song.</li>
		<li><b>mus_ShoesOff</b> — Disables the speed shoes mode. This changes the tempo from using speed up tempo, to the normal tempo defined for the song.</li>
		<li><b>mus_ToWater</b> — Enables <a href="#part6_2">underwater mode</a>.</li>
		<li><b>mus_OutWater</b> — Disables <a href="#part6_2">underwater mode</a>.</li>
		<li><b>mus_Pause</b> — Pauses the execution of AMPS and mutes hardware. AMPS will ignore everything except sound commands at this point.</li>
		<li><b>mus_Unpause</b> — Unpauses the execution of AMPS. Some notes will not play for a moment after the unpause, due to limitations with the hardware.</li>
		<li><b>mus_StopSFX</b> — Safely stops every sound effect. This will correctly release all hardware channels back to music.</li>
	</ul>
	<p>
		AMPS uses a sound queue for playing different sounds. The sound queue has 3 bytes and they can be used for any sound. <b>mQueue</b>
		is the equate name for this RAM space, and slots can be referred by <b>mQueue</b>, <b>mQueue+1</b> and <b>mQueue+2</b>. Only a single slot can be loaded per frame,
		and the earlier slots have priority over later slots. It is recommended that sound commands go to slot 0, music in slot 1 and sound effects in slot 2, though the
		programmer may choose to configure this differently depending on their needs. When there is no sound queued, the slots will be set to $00. This can be used to check
		if slot already contains a queued sound.
	</p>

	<h3 id="part3_1" class="bd">3.1 — Music Files</h3>
	<p>
		Music is mainly used as background music or as a jingle. Generally, whenever you want to make something that can be overridden by
		sound effects or be the main focus, music is a good choice. Music has access to all the features in AMPS and is generally more versatile than
		sound effects. Music is affected by the current tempo. There are 2 tempos: Speed shoes tempo and normal tempo. Speed shoes tempo is activated
		with a sound command (explained just above), and by default the normal tempo is used. There are 2 tempo modes, overflow and counter. Overflow tempo
		delays music by a single frame each time the tempo accumulator overflows (becomes >$FF). Each frame, the tempo value is added to the accumulator.
		Counter tempo instead holds a counter value, and it is counted down each frame. When it becomes 0, a single frame of delay is added.
		Then the counter value is also read back into the accumulator. You can change the tempo algorithm in <b>code/macro.asm</b>.
		You can see a visualization of the two methods in the below image (thanks to MarkeyJester!)
	</p>
	<p>
		Below is a tool to help you convert between different tempo algorithms.
	</p>
	<table border="1">
		<tr><td>counter</td><td><input id="tmctr" /></td><td><button onclick="tmpc('tmctr')">convert</button></td></tr>
		<tr><td>overflow</td><td><input id="tmofw" /></td><td><button onclick="tmpc('tmofw')">convert</button></td></tr>
		<tr><td>Sonic 2</td><td><input id="tmsh2" /></td><td><button onclick="tmpc('tmsh2')">convert</button></td></tr>
	</table>
	<p>
		Music also has an additional variable: Tick multiplier. For sound effects and often music, this value is set to $01, but you can use other values if
		you want to. When a delay is read from the tracker, that value is multiplied by the tick multiplier amount. Tick multiplier of $01 means it
		is the same as read, but $02 means it's twice as long, etc. There is a small issue though. If the total amount overflows the 8-bit range, you start getting
		smaller values again. As a special case, a delay of $00 is considered undefined, though in most cases it will act as if the delay was $100 frames.
		This is a limitation with the engine.
	</p>
	<p>
		Additionally, the tick multiplier field may contain extra flags. These flags tell AMPS to treat the music in special ways. They are mostly just for extra features.
		Here is a list of the special modes. I've listed the bit it detects along with the value that bit represents:
	</p>
	<ul>
		<li><b>bit 6, $40</b> — Tells AMPS that the previous song should be <a href="#part4_2">backed up</a>. This is useful for temporary sounds that
			should not restart the previous song from the beginning.</li>
		<li><b>bit 7, $80</b> — In PAL regions, Mega Drives run at 50hz as opposed to 60hz. The driver combats this by running twice every 6th frame. This causes timing
			issues with things that run for a specific amount of time. This flag disables that behavior, meaning the music runs slower, but takes the correct amount of time.</li>
	</ul>
	<p>
		The header also defines the channels that should be used for music. Currently, DAC1 and DAC2 must always be defined, even if they go unused. After DAC channels,
		FM channels and finally PSG channels are defined. FM and PSG channels always go in order and no channel can be skipped. This works differently to sound effects,
		which can be defined in any order the programmer wants. This is by design however, to reduce the size of tracker files and load times. Finally, the FM voice list comes
		right after the last channel. It does not necessarily have to contain any voices, but if some were needed that is where they should be placed. The inflexibility of
		this system is unfortunate and there are future plans to mitigate it.
	</p>
	<p>Here is an example music header:</p>
	<smps2asm><lbl>Example_Header:</lbl>
	<mac>sHeaderInit</mac>						<cmt>; this line initializes some variables required to make songs work</cmt>
	<mac>sHeaderTempo</mac>	<val>$81</val>, <val>$33</val>				<cmt>; that $8X means that the 50hz "fix" is not applied to this song.</cmt>
	<mac>sHeaderCh</mac>	<val>$03</val>, <val>$02</val>				<cmt>; first param is number of FM channels, second is PSG channels.</cmt>
	<mac>sHeaderDAC</mac>	<lbl>Example_DAC1</lbl>, <val>$08</val>, <equ>dKick</equ>		<cmt>; first param is tracker data location, second is volume, third is sample to use.</cmt>
	<mac>sHeaderDAC</mac>	<lbl>Example_DAC2</lbl>				<cmt>; you can also omit these fields and they default to $00.</cmt>
	<mac>sHeaderFM</mac>	<lbl>Example_FM1</lbl>, <val>$00</val>, <val>$00</val>			<cmt>; first param is tracker data location, second is pitch offset, third is volume.</cmt>
	<mac>sHeaderFM</mac>	<lbl>Example_FM2</lbl>, <val>$F4</val>, <val>$09</val>			<cmt>; all these channels have slightly different headers. You should use the right one.</cmt>
	<mac>sHeaderFM</mac>	<lbl>Example_FM3</lbl>, <val>$F4</val>, <val>$0D</val>			<cmt>; if you have a wrong num of channels, it will lead to an error. Double check if unsure.</cmt>
	<mac>sHeaderPSG</mac>	<lbl>Example_PSG1</lbl>, <val>$D0</val>, <val>$18</val>, <val>$00</val>, <equ>v05</equ>	<cmt>; first param is tracker data location, second is pitch offset, third is volume</cmt>
	<mac>sHeaderPSG</mac>	<lbl>Example_PSG1</lbl>, <val>$00</val>, <val>$30</val>, <val>$00</val>, <equ>v00</equ>	<cmt>; (volume is multiplied by $08), fourth is detune, and fifth is volume envelope ID</cmt>

	<cmt>; this is where the FM voices go.</cmt></smps2asm>
	<p>
		Including your music is also pretty easy. Music file names must not contain spaces or other special characters. The only valid characters are A-Z, a-z, 0-9 and _.
		Music files will be assigned an ID, and in program code, you can refer to this specific id with a special equate, named the music file name, prefixed with <b>mus_</b>.
		For example, you may have <b>mus_Something</b>. To include your music, simply open <b>code/Data.asm</b>, and locate <b>MusicIndex</b>. You will see lines starting with
		<b>ptrMusic</b>, with a name and a number. The name should simply be the file name of your music file, while the number is the speed shoes tempo value. Speed shoes tempo
		should always come right after the music file name. Here is an example:
	</p>
	<smps2asm>	<mac>ptrMusic</mac>	<lbl>Something</lbl>, <val>$10</val></smps2asm>

	<h3 id="part3_2" class="bd">3.2 — Sound Effect Files</h3>
	<p>
		Sound effects are useful when you want to play a small sound or a short jingle. They are most commonly used as feedback for the player or for enemy sounds.
		Sound effects are not affected by current tempo or by the 50hz "fix", and generally do not use the tick multiplier. Additionally, sound effects can not use
		the channel stack or gate command. These were deemed unnecessary for sound effects and are therefore not available. Sound effects share a voice bank, so the
		voices are not located after the header. Instead, they are loaded from <b>Voices.asm</b>.
	</p>
	<p>
		Sound effects have a priority system, which allows some sound effects to override others, or not, depending on the priority setting. Priorities go from
		$00 to $FF, with a higher priority being more likely to have the sound effect override others. The programmer can decide which priority
		values to give to each sound effect, but it is recommended to use $80 as the midway point, with priority values fairly close to it. In AMPS, priority values are
		stored per channel and therefore stick for the duration the channel exists. This means that priority values are computed per channel and stick for
		longer than a frame. Compared to SMPS drivers, this will make sound effects sound different and they can not override each other at a later time.
	</p>
	<p>
		Sound effects can define channels in any order, and with a standardized set of parameters. The first parameter is a set of flags that should always be the same
		according to channel type (other values have undefined behaviour). The second parameter is the actual channel type. It is preferred you use the equates provided in <b>code/macro.asm</b>
		to keep consistency. third parameter is the tracker data location, fourth parameter is pitch offset, and finally, fifth parameter is the channel volume.
		Here is an example of a sound effect header:
	</p>
	<smps2asm>	<mac>sHeaderInit</mac>						<cmt>; this line initializes some variables required to make sound effects work</cmt>
	<mac>sHeaderPrio</mac>	<val>$80</val>					<cmt>; this is the priority for all sound effect channels</cmt>
	<mac>sHeaderCh</mac>	<val>$03</val>					<cmt>; this must match the actual number of sound effect channels</cmt>
	<mac>sHeaderSFX</mac>	<val>$80</val>, <equ>ctFM5</equ>, <lbl>.FM5</lbl>, <val>$00</val>, <val>$00</val>		<cmt>; FM channels must all use $80 for the flags value</cmt>
	<mac>sHeaderSFX</mac>	<val>$A1</val>, <equ>ctPSG3</equ>, <lbl>.PSG3</lbl>, <val>$0C</val>, <val>$02</val>		<cmt>; PSG channels must all use $A1 for the flags value</cmt>
	<mac>sHeaderSFX</mac>	<val>$A0</val>, <equ>ctDAC1</equ>, <lbl>.DAC1</lbl>, <val>$00</val>, <val>$00</val>		<cmt>; DAC channels must all use $A0 or $A1 for the flags value</cmt></smps2asm>
	<p>
		Currently, sound effects may use the following channels: FM3, FM4, FM5, PSG1, PSG2, PSG3, and DAC1. FM3 may be later changed to FM2. Including sound effect files is pretty easy:
		each sound effect file name must not contain spaces or other special characters. The only valid characters are A-Z, a-z, 0-9 and _. Sound effect files will be assigned an ID, and
		in program code, you can refer to this specific ID with a special equate, named the sound effect file name, prefixed with <b>sfx_</b>. For example, you may have <b>sfx_Example</b>.
		To include your sound effects, simply open <b>code/Data.asm</b>, and locate <b>SoundIndex</b>. You will see lines starting with <b>ptrSFX</b> and a number, then a list of names. The name should
		simply be the file name of your sound effect file, while the number is a bit-field of flags. Each different set of flags should be on its own <b>ptrSFX</b> line. Here is a list of the flags.
		I've listed the bit it detects along with the value that bit represents:
	</p>
	<ul>
		<li><b>bit 1, $01</b> — Tells AMPS this sound effect should switch to the next ID every other time it is played. This is used to implement the ring speaker switching
			behaviour from Sonic games, although it could be used for any number of sound effect behaviours.</li>
		<li><b>bit 7, $80</b> — Tells AMPS this sound effect is continuous. These sound effects do not restart each time they are played. Instead, they continue in a loop inside of
			the tracker file. They are stopped only when either the sound effect is no longer being played, or some other sound effect overrides it. This effect was particularly popular
			in Sonic 3 & Knuckles, but individual sound effects in Sonic 1 and Sonic 2 use similar behaviours.</li>
	</ul>
	<p>
		Here is an example of including your sound effect:
	</p>
	<smps2asm>	<mac>ptrSFX</mac>		<val>$01</val>, <lbl>Example</lbl></smps2asm>

	<h1 id="part4" class="bd">4 — Trackers</h1>
	<p>
		In <a href="#part3">part 3</a>, <a href="#part3_1">3.1</a> and <a href="#part3_2">3.2</a> we talked about the specific differences between sound commands, music, and sound effects.
		In this part, we'll instead talk about the similarities, and dive deeper into how trackers work.
	</p>

	<h3 id="part4_1" class="bd">4.1 — Trackers Overview</h3>
	<p>
		In AMPS, a tracker is channel-specific data that tells AMPS what to do. AMPS will interpret this data and perform the actions requested by the programmer. Trackers in concept are quite
		simple, but internally are not very simple. AMPS aims to abstract much of this complexity, so the programmer has to worry about it as little as possible. Trackers are split into 3 types
		of data: Tracker commands, notes, and delays. For this section, we will focus on notes and delays, and we'll dive deeper into tracker commands in <a href="#part4_2">the next part</a>.
	</p>
	<p>
		AMPS uses delays to know for how long to not read from the tracker. Each channel has a stored note duration and active note duration. Together with delays, tick multipliers, and tempo
		(sound effects ignore tempo), the note duration is calculated. Every frame, channels will decrease this timer, and if it reaches 0, the tracker is processed again. To make FM, DAC, and PSG compatible,
		different initial values are loaded into the delay when channels are started (such as when a new music or sound effect is loaded). A delay of $00 frames is considered undefined behaviour, but the
		engine properly supports any delays between $01 and $7F frames. Most songs will use $0C frames per beat and multiples or divisions of $0C for other delays, but any other value can also be used.
		It is important to remember that if the tick multiplier is high and the delay value is also high, an overflow may happen, where the delay would be >$FF frames. This, in reality, will lead to a delay
		less than the intended amount. This is considered bad practice and should be avoided.
	</p>
	<p>
		AMPS uses notes as a means of representing frequency values. PSG, FM, and DAC all have different tables for defining the intended frequency based on the note, but that is rarely something the programmer
		has to worry about. Instead, it's common to use the provided equates in <b>code/smps2asm.asm</b> as guidelines for note values. There are 12 notes per octave for each type of hardware, and they should
		roughly sound accurate to real instruments, although it can also depend on the instrument and what kind of hardware voice is used. The programmer can decide to create their own pitch tables or even use
		a different number of notes per octave, but this is not officially supported with AMPS. Notes go from $80 to $DF, and $80 always represents a rest, where no note will be played, but instead, the note is set
		to decay (when applicable). Playing notes is affected by the transposition of the channel. Transposition will be added to the note value read from the tracker, so another note may actually be played. This is
		very useful when multiple channels may share routines, or the same routine is used multiple times at different keys. It is important to keep this fact in mind, as it can be both useful and confusing.
	</p>
	<p>
		There is a very specific order of operations when it comes to trackers in AMPS. First off, all commands are executed in order. Few commands will stop the tracker completely, in which case the rest of the
		process is abandoned. However, if that does not happen, AMPS expects either a note or a delay to happen at some point. If a delay is read, the last note is used to play again. If no note was played yet,
		the result is undefined behaviour. AMPS will also correctly remember if a rest was played. AMPS will stop reading the tracker, process the delay, and continue to do standard note-on behaviour unless a
		hold command was played. However, if a note is played instead, AMPS will read its frequency from the appropriate table, and then check the next byte. If this byte is a delay, the delay is also read and processed.
		There must be no other commands or notes before the delay for this to happen. Again, if no delay was ever played, this is considered undefined behaviour. AMPS will stop reading the tracker, process the delay,
		and continue to do standard note-on behaviour unless a hold command was played. Although these three approaches may seem confusing and unnecessary, it actually helps to avoid repeating yourself and save some ROM
		space. It may not be necessary, but it will help those who want it. More about frequencies can be read from <a href="#part5">part 5</a>. Below, you can see a demonstration of how this works:
	</p>
	<smps2asm>	<opc>dc.b</opc> <equ>nRst</equ>, <val>$0C</val>			<cmt>; play a rest note for $0C frames</cmt>
	<opc>dc.b</opc> <equ>nE4</equ>			<cmt>; play E4 note for $0C frames</cmt>
	<mac>saVol</mac>		<val>$04</val>		<cmt>; increase channel volume by $04</cmt>
	<opc>dc.b</opc> <val>$06</val>			<cmt>; play E4 note for $06 frames</cmt>
	<opc>dc.b</opc> <equ>nF4</equ>			<cmt>; play F4 note for $06 frames</cmt>
	<mac>saVol</mac>		<val>-$04</val>		<cmt>; decrease channel volume by $04</cmt>
	<opc>dc.b</opc> <equ>nA4</equ>, <val>$0C</val>			<cmt>; play A4 note for $0C frames</cmt></smps2asm>
	<p>
		A small note here is that when a DAC channel is in sample mode, instead of using the note to read from the frequency table, it instead reads the note as a sample to play. This is very useful when the channel does not
		need to change the frequency often, and is instead primarily used to play different samples. By default, DAC channels use this mode, but the user can change it depending on preference. More about this is is explained in
		<a href="#part4_2">the next section</a>.
	</p>

	<h3 id="part4_2" class="bd">4.2 — Tracker Commands</h3>
	<p>
		AMPS has a large variety of tracker commands. Although not all of them will be useful for every person, but they exist nonetheless to help people make music in their way. Tracker commands go from $E0 to $FF. $FF is a
		special command, so called "meta command". This command reads another byte from tracker, to act as an extra routine. This way, there is more space for commands, at the cost of extra ROM space required. Below, I will list
		all the tracker commands in AMPS, their numerical codes, and the parameters they use. All parameters enclosed &lt;like this&gt; are required, while parameters enclosed [like this] are optional.
		I will also explain how each tracker command works:
	</p>
	<h4>$E0 — ssPan &lt;pan&gt;, [ams], [fms]</h4>
	<p>
		This command is used to set the YM2612 panning for the current channel. This command only works for FM and DAC channels. YM2612 uses channel panning to determine which speaker to play audio on for
		different sound channels. There is a flaw however: Since both DAC channels and FM6 are technically the same channel for YM2612, they can only pan together. This is why, both active DAC channels or
		their panning value together. If DAC1's panning is set to $80, and DAC 2's $40, the resulting panning value is $C0. DAC1 sound effects override the panning value for DAC1 music. Currently, panning on
		FM6 when any DAC channel is running, is considered undefined behaviour, and is therefore disabled in safe mode. This command is skipped when condition is false.
	</p>
	<p>
		The three arguments for ssPan all are used to set the panning value. Since the <a href="https://www.smspower.org/maxim/Documents/YM2612#regb4">panning register is shared with the AMS/FMS data</a> for LFO,
		you can set both using this command. However, if LFO is not enabled by the tracker, setting AMS/FMS values is considered undefined behaviour. The <b>&lt;pan&gt;</b> parameter can be used to either only set
		the panning values, or the entire byte. <b>[ams]</b> and <b>[fms]</b> can also be used to set the AMS/FMS values too. They're shifted in place correctly. Below is a table of pre-defined equates for panning values:
	</p>
	<ul>
		<li><b>$00, spNone</b> — Sets panning to neither speaker. This effectively mutes the channel. However, setting DAC2 music channel to panned to neither is actually recommended. Using DAC1, it is then possible to
			pan the channel in the appropriate speaker at any time.</li>
		<li><b>$40, spRight</b> — Sets panning to the right speaker.</li>
		<li><b>$80, spLeft</b> — Sets panning to the left speaker.</li>
		<li><b>$C0, spCentre</b> — Sets panning to both of the speakers, effectively making it centered.</li>
		<li><b>$C0, spCenter</b> — Silly americans =U</li>
	</ul>
	<h4>$E1 — ssDetune &lt;val&gt;</h4>
	<p>
		Sets the channel detune to <b>&lt;val&gt;</b>. Detune is used to change the frequency of the channel slightly. <a href="#part5">You can read more about how this works here.</a> This command is skipped when condition is false.
	</p>
	<h4>$E2 — saDetune &lt;val&gt;</h4>
	<p>
		Adds <b>&lt;val&gt;</b> to the channel detune. Detune is used to change the frequency of the channel slightly. <a href="#part5">You can read more about how this works here.</a> This command is skipped when condition is false.
	</p>
	<h4>$E3 — ssTranspose &lt;val&gt;</h4>
	<p>
		Sets the channel pitch to <b>&lt;val&gt;</b>. Pitch is used to change which votes are played, adding channel pitch to the note being played. This is very useful when you want to share routines
		between FM, PSG and DAC, or for reusing the routine but just transposed. This command is skipped when condition is false.
	</p>
	<h4>$E4 — saTranspose &lt;val&gt;</h4>
	<p>
		Adds <b>&lt;val&gt;</b> to the channel pitch. Pitch is used to change which votes are played, adding channel pitch to the note being played. This is very useful when you want to share routines
		between FM, PSG and DAC, or for reusing the routine but just transposed. This command is skipped when condition is false.
	</p>
	<h4>$E5 — ssTickMulCh &lt;val&gt;</h4>
	<p>
		Sets channel tick multiplier to <b>&lt;val&gt;</b>. Tick multiplier is used to multiply the delay read from tracker by the tick multiplier value. This is used for some songs.
		<a href="#part4_1">See the previous part for more details</a>. This command is skipped when condition is false.
	</p>
	<h4>$E6 — ssTickMul &lt;val&gt;</h4>
	<p>
		Sets tick multiplier for every channel to <b>&lt;val&gt;</b>. Tick multiplier is used to multiply the delay read from tracker by the tick multiplier value. This is used for some songs.
		<a href="#part4_1">See the previous part for more details</a>. This command is skipped when condition is false.
	</p>
	<h4>$E7 — sHold</h4>
	<p>
		Toggles the channels hold flag. The hold flag prevents AMPS from processing the normal note on/note off behaviour and resetting internal flags, for example, modulation.
		The result is that the sound will continue uninterrupted, but you can also add extra tracker commands or delay to your notes. This allows delays longer than $100 frames to be set in
		the tracker as if it was a continuous note. If you play another note the frequency will be updated but note will not be restarted.
	</p>
	<h4>$E8 — sVoice &lt;val&gt;</h4>
	<p>
		Sets FM voice to &lt;val&gt; or DAC sample to &lt;val&gt;. Using this command on a PSG channel is considered undefined behaviour. Additionally, using this command on a DAC channel when
		pitch mode is enabled is considered undefined behaviour. Read more about how FM voices work at <a href="#part4_4">part 4.4.</a> This command is skipped when condition is false.
	</p>
	<h4>$E9 — ssTempoShoes &lt;tempo&gt;</h4>
	<p>
		Sets the speed shoes tempo to <b>&lt;tempo&gt;</b>. You can read more about tempos and how they work at <a href="#part3_1">part 3.1</a>. This command is skipped when condition is false.
	</p>
	<h4>$EA — ssTempo &lt;tempo&gt;</h4>
	<p>
		Sets the normal tempo to <b>&lt;tempo&gt;</b>. You can read more about tempos and how they work at <a href="#part3_1">part 3.1</a>. This command is skipped when condition is false.
	</p>
	<h4>$EB — sModeSampDAC</h4>
	<p>
		Sets the channel mode to sample mode. Using this command on a FM or PSG channel is considered undefined behaviour. Sample mode makes it so that each note read is treated as a sample
		instead of a note. This way, you can easily play different samples in quick succession. This mode is most useful when you want to play multiple different samples at the same pitch.
		You can use <b>ssFreq</b> and <b>ssFreqNote</b> to change the pitch of samples. This command is skipped when condition is false.
	</p>
	<h4>$EC — sModePitchDAC</h4>
	<p>
		Sets the channel mode to pitch mode. Using this command on a FM or PSG channel is considered undefined behaviour. Pitch mode makes it so that each note read is treated as a note
		instead of a sample. This way, you can easily play different samples at different pitches. This mode is most useful when you want to play samples many times at different pitches,
		or you want to play most of your samples at varying pitches. You can use <b>sVoice</b> to change the samples you are playing. This command is skipped when condition is false.
	</p>
	<h4>$ED — saVol &lt;vol&gt;</h4>
	<p>
		Adds <b>&lt;vol&gt;</b> to the channel volume. AMPS will update the channel volume at the end of the channel update process. <a href="#part6">You can read more about how volume works here.</a> This command is skipped when condition is false.
	</p>
	<h4>$EE — ssVol &lt;vol&gt;</h4>
	<p>
		Sets the channel volume to <b>&lt;vol&gt;</b>. AMPS will update the channel volume at the end of the channel update process. <a href="#part6">You can read more about how volume works here.</a> This command is skipped when condition is false.
	</p>
	<h4>$EF — ssLFO &lt;reg&gt; &lt;ams&gt; [fms] [pan]</h4>
	<p>
		Enables LFO and sets up AMS, FMS and enable bits for the channel. LFO is a YM2612 effect that changes the volume and frequency of the sound being generated. Unlike software effects, LFO
		can change volume and frequency many times a frame, with some values sounding much like shouting into a spinning fan. LFO speed settings are global for each channel, but every channel can
		define how strongly they are affected. Changing the global settings while multiple channels have LFO enabled affects each channel. The &lt;reg&gt; parameter is used to control which operators
		to enable AMS for, <a href="https://www.smspower.org/maxim/Documents/YM2612#reg22">and the LFO frequency</a>. See the table below:
	</p>
	<table border="1">
		<tr><td>bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
		<tr><td>val</td><td>$80</td><td>$40</td><td>$20</td><td>$10</td><td>$08</td><td>$04</td><td>$02</td><td>$01</td></tr>
		<tr><td>use</td><td>Enable op 1</td><td>Enable op 3</td><td>Enable op 2</td><td>Enable op 4</td><td>Enable LFO</td><td colspan="4">LFO Frequency</td></tr>
	</table>
	<p>
		The &lt;ams&gt;, [fms] and [pan] parameters can be used together to define the <a href="https://www.smspower.org/maxim/Documents/YM2612#regb4">AMS and FMS sensitivity, and channel panning</a>.
		The &lt;ams&gt; parameter can be used to set the entire byte value, or only the AMS sensitivity. &lt;ams&gt; [fms] are shifted in the correct places when the &lt;ams&gt; parameter is not used alone,
		and [pan] parameter expects normal values for it. Below is a table of pre-defined equate values for panning:
	</p>
	<ul>
		<li><b>$00, spNone</b> — Sets panning to neither speaker. This effectively mutes the channel. However, setting DAC2 music channel to panned to neither is actually recommended. Using DAC1, it is then possible to
			pan the channel in the appropriate speaker at any time.</li>
		<li><b>$40, spRight</b> — Sets panning to the right speaker.</li>
		<li><b>$80, spLeft</b> — Sets panning to the left speaker.</li>
		<li><b>$C0, spCentre</b> — Sets panning to both of the speakers, effectively making it centered.</li>
		<li><b>$C0, spCenter</b> — Silly americans =U</li>
	</ul>
	<p>
		This command is skipped when condition is false.
	</p>
	<h4>$F0 — ssMod68k &lt;wait&gt; &lt;speed&gt; &lt;step&gt; &lt;count&gt;</h4>
	<p>
		Initializes software frequency modulation. Modulation is useful for creating an effect where frequency moves up and/or down repeatedly, which can be used either for detuning on
		instruments or for custom effects. They are often used for sound effects to make them sound interesting, realistic or fun. They are also use in music to create bigger immersion.
		Modulation in AMPS is slightly different from SMPS games, but in general it works similarly. The &lt;wait&gt; parameter delays the start of the modulation by that number of frames,
		where 0 frames means it starts immediately. &lt;speed&gt; is the number of frames to delay until the next step is executed. 0 frames is considered undefined behaviour. &lt;step&gt;
		is the frequency offset per step. Values are sign extended, so anything above $7F is a negative value. The resulting frequency offset is 16-bit and can also be negative.
		&lt;count&gt; is the number of steps to perform before negating the &lt;step&gt; parameter. 0 steps will behave as $100 steps. For a more in-depth explanation of the algorithm,
		<a href="#part5_1">see the next part</a>. This command is skipped when condition is false.
	</p>
	<h4>$F1 — ssPortamento &lt;speed&gt;</h4>
	<p>
		Sets the portamento speed to <b>&lt;speed&gt;</b> frames, where 0 frames disables the effect. Portamento is an effect where the frequency of the previous note is blended smoothly with the current note. The <b>&lt;speed&gt;</b> parameter is used to control how long this transition takes. A speed of $01 means there is 1 frame where the
		note is transitioning to the next. In that example, the frequency will be in the middle of the 2 notes. Portamento only occurs when the next note is played, and therefore will delay the notes slightly. This also
		affects note on/off behaviour, which will happen whenever the note is played rather than when it transitions. This can be worked around with the sHold tracker command or by creating complex tracker code to execute
		the note-on when you want it to happen. This is usually not noticeable enough to matter however. <a href="#part5_2">Read more about portament in this part</a>. This command is skipped when condition is false.
	</p>
	<h4>$F2 — sVolEnv &lt;env&gt;</h4>
	<p>
		Sets the channel volume envelope to <b>&lt;env&gt;</b>. Volume envelopes are used to change the volume of a channel per frame, reading from a list. This is particularly useful for PSG channels, since they do not
		inherently have any capability to change the volume in a meaningful way otherwise. However, if FEATURE_DACFMVOLENV is enabled, DAC and FM channels can also use this functionality. More about volume envelopes in
		<a href="#part6_1">part 6.1</a>. This command is skipped when condition is false.
	</p>
	<h4>$F3 — sModEnv &lt;env&gt;</h4>
	<p>
		Sets the channel modulation envelope to <b>&lt;env&gt;</b>. Modulation envelopes are used to change the frequency of a channel per frame, reading from a list. This works similarly to volume enveloes, but has some
		differences as well. SMPS games have used this feature to create more dynamic sounding instruments. HThis feature is only available when FEATURE_MODENV is enabled. More about modulation envelopes in
		<a href="#part5">part 5</a>. This command is skipped when condition is false.
	</p>
	<h4>$F4 — sCont &lt;loc&gt;</h4>
	<p>
		Is used to make continuous sound effects work. Playing a continuous sound effect multiple times does not restart the sound effect, but instead make it continue for longer time. This makes it so that the
		sound effect can loop smoothly, and yet can be extended as necessary. This command allows continuous sound effects to check if the sound effect was played again, and if so, jump back to <b>&lt;loc&gt;</b>
		in tracker code. AMPS assumes that every sound effect channel will loop, so not looping every sound effect channel is considered undefined behaviour, though most of the time some channels will loop more times
		than others. If you do not wish a channel to play any sound after some time, loop them inside a bunch of rest notes. Additionally, all the channels should loop at the exact same tick. This command is skipped when condition is false.
	</p>
	<h4>$F5 — sStop</h4>
	<p>
		Will stop the current tracker from running, and release all the resources needed by the channel. Additionally, when sound effect channels are stopped, the music channels they were interrupting are correct restored.
		After this command, no tracker code will be executed. This command is skipped when condition is false.
	</p>
	<h4>$F6 — sJump &lt;loc&gt;</h4>
	<p>
		Sets the tracker address to be at <b>&lt;loc&gt;</b>. After this command, all tracker code is read starting from <b>&lt;loc&gt;</b>. This command is skipped when condition is false.
	</p>
	<h4>$F7 — sLoop &lt;index&gt; &lt;loops&gt; &lt;loc&gt;</h4>
	<p>
		Creates a loop between the command and the address at <b>&lt;loc&gt;</b>. This loop will be executed for <b>&lt;loops&gt;</b> times. Due to technical reasons, <b>&lt;loops&gt;</b> must be 2 or greater.
		Finally, the <b>&lt;index&gt;</b> parameter is used to identify which loop is being used. AMPS supports 3 different loop indexes, primarily used for multiple loops inside of each other. Here is a list of
		how the loop indexes are available for different channels:
	</p>
	<ul>
		<li><b>$00</b> — Always available.</li>
		<li><b>$01</b> — Available for every channel except PSG3, if FEATURE_DACFMVOLENV is disabled.</li>
		<li><b>$02</b> — Available only for music channels.</li>
	</ul>
	<p>
		This command is skipped when condition is false.
	</p>
	<h4>$F8 — sCall &lt;loc&gt;</h4>
	<p>
		Is used to temporarily run another routine, while remembering the last location we were in. The tracker address at <b>&lt;loc&gt;</b> is jumped to, while the location of the next tracker command at the previous
		address is saved to a stack. This allows us to run another routine, or even multiple other routines, before eventually returning back to the original routine. The sRet command is used to return back a level in the stack.
		This command is very useful for general routines that you may want to reuse multiple times, or even between multiple different trackers. By default, 3 different routines can be called before the stack runs out of space.
		This command is not available for sound effect channels, and attempting to use it will result in undefined behaviour. This command is skipped when condition is false.
	</p>
	<h4>$F9 — sRet</h4>
	<p>
		Is used to return from a routine called by sCall. This immediately returns to the next tracker code after the corresponding sCall command. If there are no calls present in the stack, the operation is invalid and results
		in undefined behaviour. This command is not available for sound effect channels, and attempting to use it will result in undefined behaviour. This command is skipped when condition is false.
	</p>
	<h4>$FA — sComm &lt;index&gt; &lt;val&gt;</h4>
	<p>
		Sets the communications byte <b>&lt;index&gt;</b> to <b>&lt;val&gt;</b>. Since AMPS only supports 16 communications bytes, using indexes higher than that will result in undefined behaviour. There are only 8 communications flags installed by default however.
		If you extend the number of available communications bytes, then they may be used. Read more about communications bytes in <a href="#part7">part 7</a>.
	</p>
	<h4>$FB — sCond &lt;index&gt; &lt;cond&gt; &lt;val&gt;</h4>
	<p>
		Checks the value of communications byte <b>&lt;index&gt;</b> against <b>&lt;val&gt;</b>. The command reads the byte at <b>&lt;index&gt;</b>, compares its value to <b>&lt;val&gt;</b>, and then uses
		<b>&lt;cond&gt;</b> to decide whether to set condition mode to false. When condition is false, execution of some tracker commands is disabled. To read more about this, see <a href="#part7">part 7</a>.
		Below is a table of all valid conditions:
	</p>
	<ul>
		<li><b>$00, dcoT</b> — Sets condition to true regardless.</li>
		<li><b>$01, dcoF</b> — Sets condition to false regardless.</li>
		<li><b>$02, dcoHI</b> — Sets condition to true, if <b>&lt;val&gt;</b> is greater than the communications value. This is an unsigned comparison.</li>
		<li><b>$03, dcoLS</b> — Sets condition to true, if <b>&lt;val&gt;</b> is lower than the communications value. This is an unsigned comparison.</li>
		<li><b>$04, dcoHS</b> — Sets condition to true, if <b>&lt;val&gt;</b> is greater than or equal as the communications value. This is an unsigned comparison.</li>
		<li><b>$04, dcoCC</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in carry being clear.</li>
		<li><b>$05, dcoLO</b> — Sets condition to true, if <b>&lt;val&gt;</b> is lower than or equal as the communications value. This is an unsigned comparison.</li>
		<li><b>$05, dcoCS</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in carry being set.</li>
		<li><b>$06, dcoNE</b> — Sets condition to true, if <b>&lt;val&gt;</b> does not equal the communications value.</li>
		<li><b>$07, dcoEQ</b> — Sets condition to true, if <b>&lt;val&gt;</b> does equal the communications value.</li>
		<li><b>$08, dcoVC</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in overflow being clear.</li>
		<li><b>$09, dcoVS</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in overflow being set.</li>
		<li><b>$0A, dcoPL</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in a positive value.</li>
		<li><b>$0B, dcoMI</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in a negative value.</li>
		<li><b>$0C, dcoGE</b> — Sets condition to true, if <b>&lt;val&gt;</b> is greater than or equal as the communications value. This is a signed comparison.</li>
		<li><b>$0D, dcoLT</b> — Sets condition to true, if <b>&lt;val&gt;</b> is lower than the communications value. This is a signed comparison.</li>
		<li><b>$0E, dcoGT</b> — Sets condition to true, if <b>&lt;val&gt;</b> is greater than the communications value. This is a signed comparison.</li>
		<li><b>$0F, dcoLE</b> — Sets condition to true, if <b>&lt;val&gt;</b> is lower than or equal as the communications value. This is a signed comparison.</li>
	</ul>
	<h4>$FC — sCondOff</h4>
	<p>
		Sets condition to true.
	</p>
	<h4>$FD — sGate &lt;frames&gt;</h4>
	<p>
		Sets the game timeout to <b>&lt;frames&gt;</b>. Value of 0 disables this effect. Gate cuts the sound out after a specific number of frames (not ticks!), commencing regular note off behaviour for
		the channel. This is very useful when you have a lot of notes that should stop few frames/ticks before the actual note length. Instead of placing a bunch of notes with delays, and rests with delays,
		you can optimize it to use sGate instead. Not only is this faster, but also more space-efficient. This command is not available for sound effects, and trying to use it is considered undefined behaviour. This command is skipped when condition is false.
	</p>
	<h4>$FE — sCmdYM &lt;reg&gt; &lt;val&gt;</h4>
	<p>
		Sends an YM command into YM2612. This command allows you to send any arbitrary YM2612 commands from the tracker. This command is somewhat dangerous as you can accidentally mess up something, so being extra
		careful is warranted. Additionally, your changes will NOT be saved, so if you use this in a channel that can be interrupted by sound effects, by the time it is no longer interrupted, the changes you've made
		are lost forever. This is why you should make only non-essential changes for these FM channels. The <b>&lt;reg&gt;</b> parameter is used to choose the YM2612 register to write to, while <b>&lt;val&gt;</b> is
		loaded into it. For channel-specific registers, the channel type is also added into it, so you can always get the correct register you want. This happens for registers $30 to $A7 and $A8 tp $FF. Attempting to
		write to another channels registers is considered undefined behaviour. Additionally, using this command from DAC and PSG channels are considered undefined behaviour. For a breakdown of what each registers does,
		<a href="https://www.smspower.org/maxim/Documents/YM2612">read this page</a>. This command is skipped when condition is false.
	</p>
	<h4>$FF — META</h4>
	<p>
		Reads the next byte from the tracker, and calls the following list of commands by that byte. The values are always multiples of 4 to make the code faster.
	</p>
	<h4>$FF $00 — sModOn</h4>
	<p>
		Enables modulation. Unless modulation was initialized before using ssMod68k, using this command is considered undefined behaviour.
	</p>
	<h4>$FF $04 — sModOff</h4>
	<p>
		Disables modulation. The modulation data is still remembered, but no modulation will take place until it is enabled again.
	</p>
	<h4>$FF $08 — ssFreq &lt;freq&gt;</h4>
	<p>
		Sets the channel frequency to 16-bit value <b>&lt;freq&gt;</b>. This is only useful when a DAC channel is in sample mode, where you can use this command to set the precise frequency of the channel.
		In any other case, using this command is considered undefined behaviour.
	</p>
	<h4>$FF $0C — ssFreqNote &lt;note&gt;</h4>
	<p>
		Sets the channel frequency to the frequency represented by <b>&lt;note&gt;</b>. Channel pitch also is added to <b>&lt;note&gt;</b>. This is only useful when a DAC channel is in sample mode, where you
		can use this command to set the precise frequency of the channel. In any other case, using this command is considered undefined behaviour.
	</p>
	<h4>$FF $10 — sSpinRev</h4>
	<p>
		Increases spindash counter by 1, and adds the counter value to the pitch of the channel. Only really useful for making the spindash rev sound effect work.
	</p>
	<h4>$FF $14 — sSpinReset</h4>
	<p>
		Resets spindash counter. This is used by the spindash sound effect, and various other sound effects to reset the rev counter. This makes it behave like Sonic games.
		Really useful for making the spindash rev sound effect work.
	</p>
	<h4>$FF $18 — saTempoShoes &lt;tempo&gt;</h4>
	<p>
		Adds <b>&lt;tempo&gt;</b> the speed shoes tempo. You can read more about tempos and how they work at <a href="#part3_1">part 3.1</a>.
	</p>
	<h4>$FF $1C — saTempo &lt;tempo&gt;</h4>
	<p>
		Sets <b>&lt;tempo&gt;</b> to the normal tempo. You can read more about tempos and how they work at <a href="#part3_1">part 3.1</a>.
	</p>
	<h4>$FF $20 — sCondReg &lt;off&gt; &lt;cond&gt; &lt;val&gt;</h4>
	<p>
		Checks the value of a RAM address indexed from a table (dcCondRegTable) at <b>&lt;off&gt;</b> against <b>&lt;val&gt;</b>. The command reads the byte at <b>&lt;index&gt;</b>, compares its
		value to <b>&lt;val&gt;</b>, and then uses <b>&lt;cond&gt;</b> to decide whether to set condition mode to false. When condition is false, execution of some tracker commands is disabled.
		To read more about this, see <a href="#part7">part 7</a>. Below is a table of all valid conditions:
	</p>
	<ul>
		<li><b>$00, dcoT</b> — Sets condition to true regardless.</li>
		<li><b>$01, dcoF</b> — Sets condition to false regardless.</li>
		<li><b>$02, dcoHI</b> — Sets condition to true, if <b>&lt;val&gt;</b> is greater than the communications value. This is an unsigned comparison.</li>
		<li><b>$03, dcoLS</b> — Sets condition to true, if <b>&lt;val&gt;</b> is lower than the communications value. This is an unsigned comparison.</li>
		<li><b>$04, dcoHS</b> — Sets condition to true, if <b>&lt;val&gt;</b> is greater than or equal as the communications value. This is an unsigned comparison.</li>
		<li><b>$04, dcoCC</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in carry being clear.</li>
		<li><b>$05, dcoLO</b> — Sets condition to true, if <b>&lt;val&gt;</b> is lower than or equal as the communications value. This is an unsigned comparison.</li>
		<li><b>$05, dcoCS</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in carry being set.</li>
		<li><b>$06, dcoNE</b> — Sets condition to true, if <b>&lt;val&gt;</b> does not equal the communications value.</li>
		<li><b>$07, dcoEQ</b> — Sets condition to true, if <b>&lt;val&gt;</b> does equal the communications value.</li>
		<li><b>$08, dcoVC</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in overflow being clear.</li>
		<li><b>$09, dcoVS</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in overflow being set.</li>
		<li><b>$0A, dcoPL</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in a positive value.</li>
		<li><b>$0B, dcoMI</b> — Sets condition to true, when subtracting <b>&lt;val&gt;</b> from the communications value results in a negative value.</li>
		<li><b>$0C, dcoGE</b> — Sets condition to true, if <b>&lt;val&gt;</b> is greater than or equal as the communications value. This is a signed comparison.</li>
		<li><b>$0D, dcoLT</b> — Sets condition to true, if <b>&lt;val&gt;</b> is lower than the communications value. This is a signed comparison.</li>
		<li><b>$0E, dcoGT</b> — Sets condition to true, if <b>&lt;val&gt;</b> is greater than the communications value. This is a signed comparison.</li>
		<li><b>$0F, dcoLE</b> — Sets condition to true, if <b>&lt;val&gt;</b> is lower than or equal as the communications value. This is a signed comparison.</li>
	</ul>
	<h4>$FF $24 — sPlayMus &lt;id&gt;</h4>
	<p>
		Is used to play sound effects from tracker. The sound effect <b>&lt;id&gt;</b> will be placed in the first queue slot. Unless it is overridden before the next frame, it will be played.
	</p>
	<h4>$FF $28 — sFreqOn</h4>
	<p>
		Not implemented.
	</p>
	<h4>$FF $2C — sFreqOff</h4>
	<p>
		Not implemented.
	</p>
	<h4>$FF $30 — sSpecFM3</h4>
	<p>
		Not implemented.
	</p>
	<h4>$FF $34 — ssFilter &lt;bank&gt;</h4>
	<p>
		Sets the Dual PCM volume filter bank address to <b>&lt;bank&gt;</b>. Volume filters allow PCM to sound different by replacing actual PCM values with values from the volume table. Each volume
		filter is $8000 bytes, where there are $80 volume levels with $100 possible values for each (for 8-bit PCM audio). By default, AMPS uses the logarithmic volume filter. Warning: AMPS has no logic
		to change volume filters by itself, and can only do using this command. This means, any sound effects or song changes may break things. Use this command with caution.
	</p>
	<h4>$FF $38 — sBackup</h4>
	<p>
		Stops the current music from playing, and if a song was backed up, loads it instead and start a fade in. When a song that enables the back-up flag is played, AMPS moves the old song data into
		another memory location before loading the song in. sBackup does the opposite, loading the song data from the memory location into active channel memory. It also initializes the hardware to continue
		correctly from where it left off. Fade in is done to make the transition easier, and to hide some of the sound oddities that can happen whenever this is done. Backing up songs is very useful when
		you have temporary songs that need to play, such as the 1UP music from Sonic games. This is only available if FEATURE_BACKUP is enabled. Otherwise, it is considered undefined behaviour.
	</p>
	<h4>$FF $3C — sNoisePSG &lt;val&gt;</h4>
	<p>
		Is used to set the PSG4 noise mode. PSG4 noise is useful for creating hi-hat-like effects. There are additional modes that generate different kind of noise. The command sends the PSG command
		<b>&lt;val&gt;</b> into the PSG, and sets the channel mode to PSG4, muting PSG3. Additionally, using value 0 disables this effect and restores the channel to PSG3. This is only valid for PSG3
		and PSG3 SFX channels.
	</p>
	<h4>$FF $40 — sFreeze</h4>
	<p>
		Freezes the 68k whenever this tracker command is read. It will also allow you to step over the instruction into an rts. This is very useful for debugging the 68k code at the specific position.
		Only available in safe mode, it is ignored in normal mode.
	</p>
	<h4>$FF $44 — sCheck</h4>
	<p>
		When the entire sound driver has executed, it will bring up the debugger and show various statistics about AMPS. Useful for debugging something possibly going wrong with the sound effects, music, other
		aspects of AMPS, or the programming itself. Only available in safe mode, it is ignored in normal mode.
	</p>

	<h3 id="part4_3" class="bd">4.3 — SN76496</h3>
	<p>
		The SN76496, better known as PSG, is the simplest sound chip on the Mega Drive. It really only has capability to control volume, frequency, and channel 4 noise. Although the chip is
		hilariously barebones, it can still be used to generate really interesting sounds. PSG is a squarewave generator chip, which means that each noise goes from mute to max volume nearly
		instantly. Due to limitations with filteration and the sound chip itself, it looks less like a square and more of a spiky square-like structure. The details are not overly important,
		and <a href="https://www.smspower.org/Development/SN76489">you can read more in detail about PSG here</a>. What really is important, is how AMPS interacts with the PSG chip.
	</p>
	<p>
		Although PSG has 4 channels, AMPS only supports 3 at a time. AMPS can switch between PSG3 or PSG4 mode for PSG3 channel. PSG3 mode is a normal tone channel, much like PSG1 and PSG2.
		This does not allow PSG4 to be used (though if you REALLY wanted you could do it - please don't), but is very good if you dont need it anyway. Since PSG4 allows for relatively
		unconvincing but reasonable hats, using PSG4 mode is more common. In this mode, PSG4 can use one of a few settings to enable noise. Below is a list of the PSG commands and their
		meanings:
	</p>
	<table border="1">
		<tr><td>PSG command</td><td>$E0</td><td>$E1</td><td>$E2</td><td>$E3</td><td>$E4</td><td>$E5</td><td>$E6</td><td>$E7</td></tr>
		<tr><td>Mode</td><td colspan="4">Periodic noise</td><td colspan="4">White noise</td></tr>
		<tr><td>Frequency</td><td>$0010</td><td>$0020</td><td>$0040</td><td>PSG3</td><td>$0010</td><td>$0020</td><td>$0040</td><td>PSG3</td></tr>
	</table>
	<p>
		Most commonly, PSG4 mode is used for songs, to add some extra depth. In AMPS, you can also enable and disable PSG4 mode with the sNoisePSG command. Using values on the table above
		you can enable it for the specific mode, and using $00 disables it. PSG4 has its own channel volume, but in case of using PSG3 mode, it does not have its own frequency. This is
		particularly problematic because usually PSG hi-hats use frequency of $0000, which is not pre-defined in the modes. It is possible to use another frequency instead and also use PSG3
		at the same time, allowing PSG to output 4 different sounds at once, but currently AMPS does not have support for that. Both sound effects and music can use PSG4 mode, and it will be
		correctly restored when sound effects end.
	</p>
	<p>
		PSG has a very small range of possible frequencies. Though this does not usually present an issue, the range of notes available in AMPS is limited. Below is a table of all notes,
		their raw values, and frequencies. There is also a special equate in AMPS, nHiHat, that corresponds to nA6 so long as there is no transposition.
	</p>

	<table border="1">
		<tr><td>octave</td><td>nC</td><td>nCs</td><td>nD</td><td>nEb</td><td>nE</td><td>nF</td><td>nFs</td><td>nG</td><td>nAb</td><td>nA</td><td>nBb</td><td>nB</td></tr>
<tr><td>0</td><td>$81, $03FF</td><td>$82, $03FF</td><td>$83, $03FF</td><td>$84, $03FF</td><td>$85, $03FF</td><td>$86, $03FF</td><td>$87, $03FF</td><td>$88, $03FF</td><td>$89, $03FF</td><td>$8A, $03F7</td><td>$8B, $03BE</td><td>$8C, $0388</td></tr>
<tr><td>1</td><td>$8D, $0356</td><td>$8E, $0326</td><td>$8F, $02F9</td><td>$90, $02CE</td><td>$91, $02A5</td><td>$92, $0280</td><td>$93, $025C</td><td>$94, $023A</td><td>$95, $021A</td><td>$96, $01FB</td><td>$97, $01DF</td><td>$98, $01C4</td></tr>
<tr><td>2</td><td>$99, $01AB</td><td>$9A, $0193</td><td>$9B, $017D</td><td>$9C, $0167</td><td>$9D, $0153</td><td>$9E, $0140</td><td>$9F, $012E</td><td>$A0, $011D</td><td>$A1, $010D</td><td>$A2, $00FE</td><td>$A3, $00EF</td><td>$A4, $00E2</td></tr>
<tr><td>3</td><td>$A5, $00D6</td><td>$A6, $00C9</td><td>$A7, $00BE</td><td>$A8, $00B4</td><td>$A9, $00A9</td><td>$AA, $00A0</td><td>$AB, $0097</td><td>$AC, $008F</td><td>$AD, $0087</td><td>$AE, $007F</td><td>$AF, $0078</td><td>$B0, $0071</td></tr>
<tr><td>4</td><td>$B1, $006B</td><td>$B2, $0065</td><td>$B3, $005F</td><td>$B4, $005A</td><td>$B5, $0055</td><td>$B6, $0050</td><td>$B7, $004B</td><td>$B8, $0047</td><td>$B9, $0043</td><td>$BA, $0040</td><td>$BB, $003C</td><td>$BC, $0039</td></tr>
<tr><td>5</td><td>$BD, $0036</td><td>$BE, $0033</td><td>$BF, $0030</td><td>$C0, $002D</td><td>$C1, $002B</td><td>$C2, $0028</td><td>$C3, $0026</td><td>$C4, $0024</td><td>$C5, $0022</td><td>$C6, $0020</td><td>$C7, $001F</td><td>$C8, $001D</td></tr>
<tr><td>6</td><td>$C9, $001B</td><td>$CA, $001A</td><td>$CB, $0018</td><td>$CC, $0017</td><td>$CD, $0016</td><td>$CE, $0015</td><td>$CF, $0013</td><td>$D0, $0012</td><td>$D1, $0011</td><td>$D2, $0000</td><td colspan="2"></td></tr>
	</table>
	<p>
		Each of these notes can be converted to the following format: xy, where x is the identifier of the note (for example nEb), and y is the octave (for example 4). This would result in
		equate nEb4, which can directly be used in tracker. These note names are largely arbitary and only theoretically correspond to real instruments. Indeed, many other sound drivers on
		the Mega Drive have different frequencies for the notes anyway. These frequencies and notes are heavily based on SMPS for consistency's sake, and for no real need to change them.
	</p>
	<p>
		PSG uses a 7-bit volume in AMPS as opposed to 4-bit that the SN76496 uses. This is to make PSG more aligned with FM and DAC, but at the cost of making the PSG volumes not match
		hardware levels. AMPS lazily converts the volume simply by dividing by 8, which results in a difference to the volume curve, but is accurate enough to work. There is also special
		behaviour with frequency of PSG, where you can disable safety measures intended to stop invalid frequencies being loaded. This is, oddly, necessary for the insta-shield sound effect
		in Sonic 3 & Knuckles! The problem with not capping the frequency is that it can write commands instead of frequencies into PSG, leading to undefined behaviour. For whatever reason,
		this does not seem to break anything. It is still not recommended to be used for any other reason!
	</p>

	<h3 id="part4_4" class="bd">4.4 — YM2612</h3>
	<p>
		The YM2612, also known as FM (frequency modulation), is the more complex sound chip in the Mega Drive. It is used to produce most sounds, as it has the most channels and the most rich sound
		output. It allows for a large number of parameters that change how music sounds, and more complex sinewave mixing. Although there could be a lot said about it,
		<a href="https://segaretro.org/YM2612">there are already a lot of documentation out there</a>. Instead, how FM works within AMPS is more important for this document.
	</p>
	<p>
		AMPS has support for all 6 channels at once, even while DAC is playing. Although, when DAC is not playing the mute sample (if the sample itself is mute, it does NOT count!), FM6 will be
		automatically disabled. Dual PCM is reponsible for this, which means the enabling/disabling happens immediately, not at the end of the frame. In theory, this should never lead to artifacts in
		sound, but it can sound weird if samples go in and out all the time. You need to enable FEATURE_FM6 in order to use FM6. Additionally, panning in FM6 is currently not implemented correctly. It
		overrides panning for both DAC channels, and vice versa too. The results of that are considered undefined behaviour, so panning on FM6 is not recommended.
	</p>
	<p>
		AMPS uses FM voice tables to load FM instruments. Music has a single table for all its channels, and sound effects use a common table for all voices. Unlike in SMPS, AMPS uses a more efficient
		format where loading any voice is as fast as any other. Therefore, a globabl voice table for sound effects actually improves performance overall. Instruments can be given unique names so that
		removing or adding them can be done without breaking anything. The global voice table for sound effects is in <b>Voices.S2A</b>. Below is an example of a voice, along with the more common names
		for each parameter:
	</p>
	<smps2asm>	<cmt>; Voice $00</cmt>
	<mac>spAlgorithm</mac>	<val>$04</val>, <lbl>Rings</lbl>			<cmt>; Algorithm. The second parameter defines the name, in this case, pRings</cmt>
	<mac>spFeedback</mac>	<val>$00</val>				<cmt>; Feedback</cmt>
	<mac>spDetune</mac>	<val>$03</val>, <val>$07</val>, <val>$07</val>, <val>$04</val>		<cmt>; Detune</cmt>
	<mac>spMultiple</mac>	<val>$07</val>, <val>$07</val>, <val>$02</val>, <val>$09</val>		<cmt>; Multiple</cmt>
	<mac>spRateScale</mac>	<val>$00</val>, <val>$00</val>, <val>$00</val>, <val>$00</val>		<cmt>; Rate Scaling</cmt>
	<mac>spAttackRt</mac>	<val>$1F</val>, <val>$1F</val>, <val>$1F</val>, <val>$1F</val>		<cmt>; Attack Rate</cmt>
	<mac>spAmpMod</mac>	<val>$00</val>, <val>$00</val>, <val>$00</val>, <val>$00</val>		<cmt>; Amplitude Modulation</cmt>
	<mac>spSustainRt</mac>	<val>$07</val>, <val>$07</val>, <val>$0A</val>, <val>$0D</val>		<cmt>; First Decay Rate; Decay 1 Rate</cmt>
	<mac>spSustainLv</mac>	<val>$01</val>, <val>$01</val>, <val>$00</val>, <val>$00</val>		<cmt>; Secondary Amplitude; Decay Level</cmt>
	<mac>spDecayRt</mac>	<val>$00</val>, <val>$00</val>, <val>$0B</val>, <val>$0B</val>		<cmt>; Second Decay Rate; Decay 2 Rate</cmt>
	<mac>spReleaseRt</mac>	<val>$0F</val>, <val>$0F</val>, <val>$0F</val>, <val>$0F</val>		<cmt>; Release Rate</cmt>
	<mac>spSSGEG</mac>		<val>$00</val>, <val>$00</val>, <val>$00</val>, <val>$00</val>		<cmt>; SSG-EG. This was introduced in AMPS.</cmt>
	<mac>spTotalLv</mac>	<val>$23</val>, <val>$23</val>, <val>$00</val>, <val>$00</val>		<cmt>; Total Level</cmt></smps2asm>
	<p>
		Each voice in AMPS is 32 bytes in size, and has 3 unused bytes. This is done for the sake of alignment and efficiency. The above parameters are used to define each instrument, and they are sent
		to YM2612 via Dual PCM. This means, that the timings between voices and notes are different to SMPS and therefore some things will sound different. This sometimes causes perfectly good sound
		effects from SMPS games to sound absolute thrash in AMPS. This is largely unavoidable and there seems to be no real solution to this issue. Potential fixes are being investigated but there is no
		guarantee for it.
	</p>
	<p>
		FM has $80 total volume levels per operator and depending on the algorithm, different operators act as the volume (slot operators), and others as modulators (nonslot operators). SMPS2ASM will
		correctly tell AMPS which operators are used for which purpose, but this can be changed by the programmer if they wish to have different behaviour. It is not recommended, unless the programmer
		knows what they are doing. All the slot operators can have different total level values, as they are simply just added into the calculated volume. Additionally, <a href="#part6_2">underwater
		mode</a> changes the slot and nonslot total levels too.
	</p>
	<p>
		You can send arbitary YM2612 commands from tracker as well. This is useful for editing single instrument parameters or doing some more uncommon tricks. This is dangerous, because if a sound
		effect interrupts the channel, all your changes are lost. Indeed, relying on changes to stick is a terrible idea. Additionally, songs that use the backup system will also make these changes be
		lost, this time in every FM channel. Some other settings, such as LFO, will neither stick around correctly. However, because SSG-EG is in the instrument data, it will always be restored.
	</p>
	<p>
		YM2612 has an interesting frequency range. It has frequencies from $000 to $7FF, and octaves from $00xx to $38xx. Each octave, well, is an octave higher than the previous. However, the frequency
		between octaves also has some overlap. A lower octave frequency may sound the same as higher octave frequency, but earlier from the frequency range. To put it more simply, $4C0 may sound the same
		as $A5C. The point where this happens precisely is not known yet, but the estimate provided is close enough. Below is a table of all notes, their raw values, and frequencies.
	</p>

	<table border="1">
		<tr><td>octave</td><td>nC</td><td>nCs</td><td>nD</td><td>nEb</td><td>nE</td><td>nF</td><td>nFs</td><td>nG</td><td>nAb</td><td>nA</td><td>nBb</td><td>nB</td></tr>
<tr><td>-1</td><td colspan="11"></td><td>$80, $025E</td></tr>
<tr><td>0</td><td>$81, $0284</td><td>$82, $02AB</td><td>$83, $02D3</td><td>$84, $02FE</td><td>$85, $032D</td><td>$86, $035C</td><td>$87, $038F</td><td>$88, $03C5</td><td>$89, $03FF</td><td>$8A, $043C</td><td>$8B, $047C</td><td>$8C, $0A5E</td></tr>
<tr><td>1</td><td>$8D, $0A84</td><td>$8E, $0AAB</td><td>$8F, $0AD3</td><td>$90, $0AFE</td><td>$91, $0B2D</td><td>$92, $0B5C</td><td>$93, $0B8F</td><td>$94, $0BC5</td><td>$95, $0BFF</td><td>$96, $0C3C</td><td>$97, $0C7C</td><td>$98, $125E</td></tr>
<tr><td>2</td><td>$99, $1284</td><td>$9A, $12AB</td><td>$9B, $12D3</td><td>$9C, $12FE</td><td>$9D, $132D</td><td>$9E, $135C</td><td>$9F, $138F</td><td>$A0, $13C5</td><td>$A1, $13FF</td><td>$A2, $143C</td><td>$A3, $147C</td><td>$A4, $1A5E</td></tr>
<tr><td>3</td><td>$A5, $1A84</td><td>$A6, $1AAB</td><td>$A7, $1AD3</td><td>$A8, $1AFE</td><td>$A9, $1B2D</td><td>$AA, $1B5C</td><td>$AB, $1B8F</td><td>$AC, $1BC5</td><td>$AD, $1BFF</td><td>$AE, $1C3C</td><td>$AF, $1C7C</td><td>$B0, $225E</td></tr>
<tr><td>4</td><td>$B1, $2284</td><td>$B2, $22AB</td><td>$B3, $22D3</td><td>$B4, $22FE</td><td>$B5, $232D</td><td>$B6, $235C</td><td>$B7, $238F</td><td>$B8, $23C5</td><td>$B9, $23FF</td><td>$BA, $243C</td><td>$BB, $247C</td><td>$BC, $2A5E</td></tr>
<tr><td>5</td><td>$BD, $2A84</td><td>$BE, $2AAB</td><td>$BF, $2AD3</td><td>$C0, $2AFE</td><td>$C1, $2B2D</td><td>$C2, $2B5C</td><td>$C3, $2B8F</td><td>$C4, $2BC5</td><td>$C5, $2BFF</td><td>$C6, $2C3C</td><td>$C7, $2C7C</td><td>$C8, $325E</td></tr>
<tr><td>6</td><td>$C9, $3284</td><td>$CA, $32AB</td><td>$CB, $32D3</td><td>$CC, $32FE</td><td>$CD, $332D</td><td>$CE, $335C</td><td>$CF, $338F</td><td>$D0, $33C5</td><td>$D1, $33FF</td><td>$D2, $343C</td><td>$D3, $347C</td><td>$D4, $3A5E</td></tr>
<tr><td>7</td><td>$D5, $3A84</td><td>$D6, $3AAB</td><td>$D7, $3AD3</td><td>$D8, $3AFE</td><td>$D9, $3B2D</td><td>$DA, $3B5C</td><td>$DB, $3B8F</td><td>$DC, $3BC5</td><td>$DD, $3BFF</td><td>$DE, $3C3C</td><td>$DF, $3C7C</td><td></td></tr>
	</table>

	<h3 id="part4_5" class="bd">4.5 — Dual PCM</h3>
	<p>
		Dual PCM FlexEd is not an actual sound chip, but rather a piece of software that is responsible for dealing with PCM audio and YM2612 commands. Dual PCM is heavily integrated with
		AMPS to give the best possible user experience. It allows playing back 2 PCM samples at once, with the ability to change pitch and volume as well. Although Dual PCM is "only" 14KHz
		8-bit PCM audio per channel, it still leads to excellent audio quality. <a href="Dual PCM - FlexEd (Technical Document).pdf" target="_blank">There is in-depth documentation
		available for Dual PCM</a>, so I will not dive too deeply into how it works. Instead, I will focus more on how AMPS interacts with it.
	</p>
	<p>
		Dual PCM uses SWF format for samples. This is a custom PCM format specifically for use with Dual PCM. AMPS stores raw samples in the <b>dac</b> folder, and <b>ConvPCM.exe</b> is used to convert
		general sample formats to SWF. After this, SWF files should be stored in <b>dac/incSWF</b>. AMPS will access files from there. Samples are included in <b>code/Data.asm</b>, at the bottom of the
		file. There should be a bunch of <b>incSWF</b> statements with names on them. These are file names of the individual samples. They should only contain A-Z, a-z, 0-9 and _, otherwise they wont be
		assembled correctly. AMPS will generate the necessary structures to include the file into the disassembly. You need to add samples into the bottom of the file before you can use them in your
		trackers. Also, you need to define data for them. At SampleList, you will see a list of defined tracker samples. These define the settings and names for the samples. Here is an example:
	</p>
	<asm>	<mac>sample</mac> <val>$0180</val>, <equ>Tom</equ>, <equ>Stop</equ>, <equ>HiTom</equ>		<cmt>; High Tom</cmt></asm>
	<p>
		This defines a sample, with equate name <b>dHiTom</b>, with base frequency of $180. This frequency is added to calculated frequency whenever it is updated. Frequency of $0100 is the neutral
		frequency, where the sample speed/frequency is at 100%. The higher the frequency goes, the faster the sample is, same for lower. Negative values make it go backwards (from the end to start). The
		sample name <b>Tom</b> is loaded from memory to start the sample, and the sample <b>Stop</b> is loaded as the looping point. This makes the Tom sample play fully before the sound is stopped. You
		could insert another sample as the loop sample, and you'd get an infinitely looping sample (so long as a note is played that is). Defining a 3rd name, in this case <b>HiTom</b> is not required.
		Omitting it means the first name, <b>Tom</b> in this case, uses that name for the sample equate. That would result in <b>dTom</b>. Here is an example of that:
	</p>
	<asm>	<mac>sample</mac> <val>$0100</val>, <equ>Tom</equ>, <equ>Stop</equ>			<cmt>; Mid Tom</cmt></asm>
	<p>
		The looping happens internally in Dual PCM rather than with AMPS, so it can be very useful for creating samples that repeat in quicker than per frame. Making the samples too short will lead to a
		lot of quality loss, so sometimes repeating the sample a few times is a good idea. Adding a lot of blank space at the end of the sample can inflate the ROM size however, so use these tricks very
		carefully.
	</p>
	<p>
		DAC channels have 2 modes: Sample mode and pitch mode. These can be selected using tracker commands sModeSampDAC and sModePitchDAC. In sample mode, each note represents a sample to be used at the
		current channel pitch. AMPS will also remember what sample was last used and it will work like channels normally with the exception that you're changing the sample, not the pitch. Pitch mode is
		how channels work normally, every note represents a frequency from the frequency table. The last used sample is used to play the new note. You can use sVoice to change the sample in pitch mode,
		and ssFreq & ssFreqNote to change the frequency of the channel in sample mode.
	</p>
	<p>
		Panning for DAC channels is bit of an exception. The 2 currently active channels add the panning value together to get the final value. If SFX DAC1 channel is active, it will override DAC1. If
		one channel is panned to the centre and other is to left, the panning will be centre anyway. It is a good idea to pan one channel to none and the other controls panning for both. This may be a
		problem when using SFX DAC1, as it can not be guaranteed to have control over panning and may cause music to sound strange. You should be careful when using panning like this.
	</p>
	<p>
		Dual PCM has $80 volume levels for samples, and it uses a table to load these volumes from. AMPS by default comes equipped with a logarithmic volume filter that mimics the perceived volume levels
		of YM2612 as closely as possible. It will never be a perfect match but its usually not noticeable. AMPS also includes a linear volume table but using this isn't really recommended. You can also
		create custom tables and use them with AMPS, but this is not properly supported at the moment, and you'd have to figure it out yourself. Because of limitations with Dual PCM, attempting to update
		volume more often than every 4 frames will lead to quality loss. In AMPS, this is done by wrapping the PCM buffers when they run out of data, so that a part of the PCM data will play twice over.
		This has been considered less distracting than stopping the sample playback outright. This is a good idea to remember for channel volumes, volume fading, volume envelopes and others.
	</p>
	<p>
		DAC has a wide range of possible frequencies, including backwards frequencies. Many of these frequencies are not particularly useful, because they go quite fast, but they are included because
		someone might find them useful or cool to experiment with. The frequency table is $100 elements long, so any note and transposition value can be used. This is done mostly to support the backwards
		frequencies correctly. It is technically possible to go over $FFF or below -$FFF in frequency, but this is not supported by the Dual PCM configuration and may lead to glitches. Below is a table
		of all notes, their raw values, and frequencies:
	</p>
	<table border="1">
		<tr><td>octave</td><td>nC</td><td>nCs</td><td>nD</td><td>nEb</td><td>nE</td><td>nF</td><td>nFs</td><td>nG</td><td>nAb</td><td>nA</td><td>nBb</td><td>nB</td></tr>
<tr><td>?</td><td colspan="11"></td><td>$80, $0000</td></tr>
<tr><td>0</td><td>$81, $0010</td><td>$82, $0011</td><td>$83, $0012</td><td>$84, $0013</td><td>$85, $0014</td><td>$86, $0015</td><td>$87, $0017</td><td>$88, $0018</td><td>$89, $0019</td><td>$8A, $001B</td><td>$8B, $001D</td><td>$8C, $001E</td></tr>
<tr><td>1</td><td>$8D, $0020</td><td>$8E, $0022</td><td>$8F, $0024</td><td>$90, $0026</td><td>$91, $0028</td><td>$92, $002B</td><td>$93, $002D</td><td>$94, $0030</td><td>$95, $0033</td><td>$96, $0036</td><td>$97, $0039</td><td>$98, $003C</td></tr>
<tr><td>2</td><td>$99, $0040</td><td>$9A, $0044</td><td>$9B, $0048</td><td>$9C, $004C</td><td>$9D, $0051</td><td>$9E, $0055</td><td>$9F, $005B</td><td>$A0, $0060</td><td>$A1, $0066</td><td>$A2, $006C</td><td>$A3, $0072</td><td>$A4, $0079</td></tr>
<tr><td>3</td><td>$A5, $0080</td><td>$A6, $0088</td><td>$A7, $0090</td><td>$A8, $0098</td><td>$A9, $00A1</td><td>$AA, $00AB</td><td>$AB, $00B5</td><td>$AC, $00C0</td><td>$AD, $00CB</td><td>$AE, $00D7</td><td>$AF, $00E4</td><td>$B0, $00F2</td></tr>
<tr><td>4</td><td>$B1, $0100</td><td>$B2, $010F</td><td>$B3, $011F</td><td>$B4, $0130</td><td>$B5, $0143</td><td>$B6, $0156</td><td>$B7, $016A</td><td>$B8, $0180</td><td>$B9, $0196</td><td>$BA, $01AF</td><td>$BB, $01C8</td><td>$BC, $01E3</td></tr>
<tr><td>5</td><td>$BD, $0200</td><td>$BE, $021E</td><td>$BF, $023F</td><td>$C0, $0261</td><td>$C1, $0285</td><td>$C2, $02AB</td><td>$C3, $02D4</td><td>$C4, $02FF</td><td>$C5, $032D</td><td>$C6, $035D</td><td>$C7, $0390</td><td>$C8, $03C7</td></tr>
<tr><td>6</td><td>$C9, $0400</td><td>$CA, $043D</td><td>$CB, $047D</td><td>$CC, $04C2</td><td>$CD, $050A</td><td>$CE, $0557</td><td>$CF, $05A8</td><td>$D0, $05FE</td><td>$D1, $0659</td><td>$D2, $06BA</td><td>$D3, $0721</td><td>$D4, $078D</td></tr>
<tr><td>7</td><td>$D5, $0800</td><td>$D6, $087A</td><td>$D7, $08FB</td><td>$D8, $0983</td><td>$D9, $0A14</td><td>$DA, $0AAE</td><td>$DB, $0B50</td><td>$DC, $0BFD</td><td>$DD, $0CB3</td><td>$DE, $0D74</td><td>$DF, $0E41</td><td>$E0, $0F1A</td></tr>
<tr><td>8</td><td>$E1, $0FFF</td><td>$E2, $0FFF</td><td>$E3, $0FFF</td><td>$E4, $0FFF</td><td>$E5, $0FFF</td><td>$E6, $0FFF</td><td>$E7, $0FFF</td><td>$E8, $0FFF</td><td>$E9, $0FFF</td><td>$EA, $0FFF</td><td>$EB, $0FFF</td><td>$EC, $0FFF</td></tr>
<tr><td>9</td><td>$ED, $0FFF</td><td>$EE, $0FFF</td><td>$EF, $0FFF</td><td>$F0, $0FFF</td><td>$F1, $0FFF</td><td>$F2, $0FFF</td><td>$F3, $0FFF</td><td>$F4, $0FFF</td><td>$F5, $0FFF</td><td>$F6, $0FFF</td><td>$F7, $0FFF</td><td>$F8, $0FFF</td></tr>
<tr><td>10</td><td>$F9, $0FFF</td><td>$FA, $0FFF</td><td>$FB, $0FFF</td><td>$FC, $0FFF</td><td>$FD, $0FFF</td><td>$FE, $0FFF</td><td>$FF, $0FFF</td><td colspan="5"></td></tr>
<tr><td>-10</td><td colspan="4"></td><td>$00, -$FFF</td><td>$01, -$FFF</td><td>$02, -$FFF</td><td>$03, -$FFF</td><td>$04, -$FFF</td><td>$05, -$FFF</td><td>$06, -$FFF</td><td>$07, -$FFF</td></tr>
<tr><td>-9</td><td>$08, -$FFF</td><td>$09, -$FFF</td><td>$0A, -$FFF</td><td>$0B, -$FFF</td><td>$0C, -$FFF</td><td>$0D, -$FFF</td><td>$0E, -$FFF</td><td>$0F, -$FFF</td><td>$10, -$FFF</td><td>$11, -$FFF</td><td>$12, -$FFF</td><td>$13, -$FFF</td></tr>
<tr><td>-8</td><td>$14, -$FFF</td><td>$15, -$FFF</td><td>$16, -$FFF</td><td>$17, -$FFF</td><td>$18, -$FFF</td><td>$19, -$FFF</td><td>$1A, -$FFF</td><td>$1B, -$FFF</td><td>$1C, -$FFF</td><td>$1D, -$FFF</td><td>$1E, -$FFF</td><td>$1F, -$FFF</td></tr>
<tr><td>-7</td><td>$20, -$F1A</td><td>$21, -$E41</td><td>$22, -$D74</td><td>$23, -$CB3</td><td>$24, -$BFD</td><td>$25, -$B50</td><td>$26, -$AAE</td><td>$27, -$A14</td><td>$28, -$983</td><td>$29, -$8FB</td><td>$2A, -$87A</td><td>$2B, -$800</td></tr>
<tr><td>-6</td><td>$2C, -$78D</td><td>$2D, -$721</td><td>$2E, -$6BA</td><td>$2F, -$659</td><td>$30, -$5FE</td><td>$31, -$5A8</td><td>$32, -$557</td><td>$33, -$50A</td><td>$34, -$4C2</td><td>$35, -$47D</td><td>$36, -$43D</td><td>$37, -$400</td></tr>
<tr><td>-5</td><td>$38, -$3C7</td><td>$39, -$390</td><td>$3A, -$35D</td><td>$3B, -$32D</td><td>$3C, -$2FF</td><td>$3D, -$2D4</td><td>$3E, -$2AB</td><td>$3F, -$285</td><td>$40, -$261</td><td>$41, -$23F</td><td>$42, -$21E</td><td>$43, -$200</td></tr>
<tr><td>-4</td><td>$44, -$1E3</td><td>$45, -$1C8</td><td>$46, -$1AF</td><td>$47, -$196</td><td>$48, -$180</td><td>$49, -$16A</td><td>$4A, -$156</td><td>$4B, -$143</td><td>$4C, -$130</td><td>$4D, -$11F</td><td>$4E, -$10F</td><td>$4F, -$100</td></tr>
<tr><td>-3</td><td>$50, -$0F2</td><td>$51, -$0E4</td><td>$52, -$0D7</td><td>$53, -$0CB</td><td>$54, -$0C0</td><td>$55, -$0B5</td><td>$56, -$0AB</td><td>$57, -$0A1</td><td>$58, -$098</td><td>$59, -$090</td><td>$5A, -$088</td><td>$5B, -$080</td></tr>
<tr><td>-2</td><td>$5C, -$079</td><td>$5D, -$072</td><td>$5E, -$06C</td><td>$5F, -$066</td><td>$60, -$060</td><td>$61, -$05B</td><td>$62, -$055</td><td>$63, -$051</td><td>$64, -$04C</td><td>$65, -$048</td><td>$66, -$044</td><td>$67, -$040</td></tr>
<tr><td>-1</td><td>$68, -$03C</td><td>$69, -$039</td><td>$6A, -$036</td><td>$6B, -$033</td><td>$6C, -$030</td><td>$6D, -$02D</td><td>$6E, -$02B</td><td>$6F, -$028</td><td>$70, -$026</td><td>$71, -$024</td><td>$72, -$022</td><td>$73, -$020</td></tr>
<tr><td>-0</td><td>$74, -$01E</td><td>$75, -$01D</td><td>$76, -$01B</td><td>$77, -$019</td><td>$78, -$018</td><td>$79, -$017</td><td>$7A, -$015</td><td>$7B, -$014</td><td>$7C, -$013</td><td>$7D, -$012</td><td>$7E, -$011</td><td>$7F, -$010</td></tr>
	</table>
	<p>
		Each of these notes can be converted to the following format: xy, where x is the identifier of the note (for example nA), and y is the octave (for example 2). This would result in
		equate nA2, which can directly be used in tracker. These note names are largely arbitary and only theoretically correspond to real instruments. Majority of these notes are only accessible with
		transposition. Afterall, you can only play $81 to $DF using the tracker by default. Although, with ssFreqNote, you can actually play any of these notes at any time in sample mode.
	</p>

	<script>
		/*
		var str = "", ln = "", lnum = 0, note = 0x81;
		var oops = `
		`;

		for(let x of oops.split("\n")){
			ln = "<tr><td>"+ lnum++ +"</td>";

			for(let n of x.split(",")){
				n = n.replace(",", "").trim();
				ln += "<td>$"+ note.toString(16).toUpperCase() +", "+ n +"</td>";
				note++;
			}

			str += ln + "</tr>\n";
		}

		console.log(str);
		// Real Programmers Don't Use SMPS
*/
	</script>

	<h1 id="part5" class="bd">5 — Frequency</h1>
	<p>
		In AMPS, frequency depends entirely on the sound hardware used. You can see the actual tables used in previous parts for <a href="#part4_4">FM</a>, <a href="#part4_3">PSG</a>
		and <a href="#part4_5">DAC</a>. This is why AMPS abstracts actual frequencies as notes, which are mostly consistent with each other. Transposition is also used to shift the notes
		around to read different entries from the frequency table. This is most useful for DAC which has negative not frequencies not accessible otherwise. Attempting to read an invalid note
		from these tables is considered undefined behaviour. The frequency read along with detune is used to calculate the final frequency. Additionally, modulation, portamento and
		modulation envelope are added into the frequency every frame (when active).
	</p>

	<h3 id="part5_1" class="bd">5.1 — Modulation</h3>
	<p>
		Software modulation in AMPS is similar but not quite the same to SMPS. In SMPS, the 68k versions and Z80 versions have a slightly different algorithm to each other, and AMPS is also
		slightly different in another way. The differences will be explained as I explain the algorithm. Modulation has 4 user-defined values: <b>wait</b>, <b>speed</b>, <b>step</b> & <b>
		count</b>. These help define the behaviour of the modulation process. There is also a flag that enables and disables modulation independent of setting it up, and can be controlled
		in tracker with sModOn and sModOff. These only set the state of the flag rather than modifying modulation data. Below is the explanation of the algorithm:
	</p>
	<p>
		There can be some delay before the modulation starts. If <b>wait</b> is not 0, the modulation gets delayed by that many frames instead. The <b>speed</b> parameter defines how often
		modulation is stepped forwards. Value of $00 actually represents $100, and $01 is the minimum amount (gets stepped every frame). When a step occurs, <b>step</b> is added to the
		modulation frequency offset (which is later added to channel frequency!). This value is a signed 8-bit value, -$80 to $7F, and gets extended to a 16-bit value for the purposes of
		the frequency offsetting. This allows for a great dynamic frequency range with relatively little effort. There is also the <b>count</b> variable that is the number of steps. When
		modulation is initialized, this value is halve (rounded down) and set as the initial value. This allows the modulation to go back and forth around the channel frequency, however it
		doesn't have to. When the <b>count</b> is 0, the modulation speed is negated, and step counter is reloaded. This makes the frequency offset go backwards, to approximately the
		negative value of it.
	</p>
	<p>
		There is also a trick many games use to make modulation only up/down. You can set <b>count</b> to $FF, in order to have enough steps to not run out of them. This results in a
		sequence where the <b>step</b> is never negated. If your note is veeery long, this might happen, but its rarely going to be so long in any real situation. If the <b>count</b>
		parameter is $00, it will act as $100. However, at the same time, this is undefined behaviour as of writing this tutorial.
	</p>
	<p>
		There are few interesting differences between SMPS
		versions and AMPS. In SMPS 68k, after the <b>count</b> parameter is reloaded, the rest of the modulation code is skipped. This includes decrementing the counter and processing
		frequency. This makes it so that the last step lasts 2 frames and the modulation is slightly longer. This can be simply fixed by adding 1 to the <b>count</b> parameter in your
		tracker code. SMPS Z80 is a bit more difficult. For some odd reason, it decrements modulation step counter every frame (after modulation wait delay has passed), and therefore can
		negate the direction even in the middle of the step. Also, the <b>step</b> parameter is therefore multiplied by the <b>speed</b> parameter. This is a problem particularly because its
		technically impossible to correctly recreate all modulation from SMPS Z80 games. In practice, this does not matter because you don't have to get the modulaton matching 100% to be
		good enough.
	</p>


	<h3 id="part5_2" class="bd">5.2 — Portamento</h3>
	<p>
		Portamento is an effect which allows the frequency between notes to be blended smoothly over time. FEATURE_PORTAMENTO must be enabled to use the portamento effect. Portamento effect
		has a certain speed, where $00 disables the effect, any other number indicates the number of between frames that are used for blending. Portamento uses a displacement value for
		changing offset each frame, and a frequency offset that keeps track of how far from the current note the actual frequency is supposed to be. This works irrespective of any other
		frequency effects so the results are correct every time.
	</p>
	<p>
		The algorithm for portamento simply remembers the difference of the 2 notes, and calculates using the portamento value how much to change it per frame. The algorithm skips some
		frequency ranges for FM however, because they actually overlap. This makes the effect sound almost perfect. If the difference is too small, the difference is the smallest possible
		so the note does eventually change. Previous portamento offsets are also considered, so it is safe to change the note while portamento is in progress.
	</p>
	<p>
		Every frame, portamento is processed and calculated. The portamento displacement is added to portamento offset, until it is 0, or changes sign. At this point, portamento is disabled
		until next note-on. This process again skips the FM ranges that are equivalent. Portamento from or to rests is not possible.
	</p>

	<h1 id="part6" class="bd">6 — Volume</h1>
	<p>
		Internally, AMPS uses 7-bit volume for all software channels. This makes the editing of volumes consistent between different sound hardware. This does mean, that PSG volume is
		actually multiples of 8 of the real hardware volume. AMPS lazily shifts it down instead of using a look-up-table to be more accurate. Volume levels go from $00 to $7F, where $00
		is the loudest possible and $7F is muted. Any values outside of the range are treated as $7F. Volumes depend on the hardware and other settings so comparing volumes 1:1 between
		hardware types is difficult. The volume is merely a relative measure to help the programmer adjust the music to their liking. Volume is also useful to make music fade in/out easily.
	</p>
	<p>
		There are a few factors that come into the final volume. There is master volume for each hardware type (sound effects may ignore this depending in settings), per-channel volume,
		volume envelopes, and for FM channels, total level values too. Additionally, the PCM volume levels also affect DAC channels.
	</p>

	<h3 id="part6_1" class="bd">6.1 — Channel Volumes</h3>
	<p>
		Channels exclusively handle the volume of hardware channels. Some code may mute the hardware channels, but if a volume needs to be updated, the channel will be requested to do it.
		This flag is used by the tracker, channel itself, and outside influences to correctly update the channel volume when required. This simplifies the complex process of volume updates.
		AMPS processes volume in the following order:
	</p>
	<ul>
		<li><b>channel volume</b> — Channel-specific volume. Can be used to easily change the volume of the sound but have to be careful about it as well.</li>
		<li><b>master volume</b> — For all applicable channels, master volume is loaded. Sound effects may disable master volume checks. Depending on channel type, volume is loaded from
			either mMasterVolFM, mMasterVolDAC or mMasterVolPSG</li>
		<li><b>volume envelopes</b> — Volume envelopes are processed every frame. <a href="#part7">Read more in the next part</a>.</li>
		<li><b>total level in FM channels</b> — Each FM channel has 4 total level values for each operator. Slot operators are affected by volume calculation, while non-slot aren't.</li>
		<li><b>underwater mode for FM</b> — Underwater mode also affects the volume calculation and non-slot total level value.</li>
		<li><b>PCM audio for DAC channels</b> — The PCM audio data itself is basically just a list of volumes, so it makes sense it can affect how loud the volume is.</li>
		<li><b>PSG audio filtering on real hardware</b> — PSG audio is also somewhat different relatively to FM and DAC audio in real systems. This is because of inconsistent filters
			and buggy implementation. AMPS can not do anything about this problem however.</li>
	</ul>
	<p>
		The final step of this process is to send the volume to hardware. In case of PSG, this is a single PSG command containing the volume. For FM, it is 4 total level operators per
		channel. For DAC, however, it is a bit more complex. Dual PCM uses a volume filter bank with $80 levels of volume to scale the PCM input volume. This allows for very complex filters
		or a simple filter that AMPS comes with. By default, AMPS uses a logarithmic filter that closely mimics FM volume (but not 100%). However, custom filters may be applied. There is a
		tracker commad, ssFilter, that allows to change the bank. AMPS is very lazy with handling these filters and they can also affect sound effect channels (a filter loaded with DAC1 on
		music will affect SFX DAC1, and vice versa), so you have to be careful. AMPS requests a volume update from Dual PCM in order to load the correct volume table in Z80 RAM, which then
		acts as the current filter for the current volume level. It takes some time to load the volume table in RAM, so loading a new volume only every 4 frames or more is recommended. If
		you load it more often, quality loss is likely to happen. AMPS tells Dual PCM to wrap the buffer around, so a part of the sample will repeat on itself. This is less distracting than
		the default behaviour of Dual PCM where the samples will delay for a moment. The best thing to do is avoid updating PCM volume too often.
	</p>
	<p>
		Updating PSG and DAC volume is fairly fast for the 68k to do (even given the amount of work required), but unfortunately FM volume is noticeably slower. This is mainly because of the
		4 operators that need updating, and the fact we've got to take time from Dual PCM for a while. AMPS optimizes this but at the cost of more 68k time. Avoid updating volume unless it
		is necessary!
	</p>

	<h3 id="part6_2" class="bd">6.2 — Underwater Mode</h3>
	<p>
		Underwater mode is a software effect intended to emulate the music playing under water. This is especially useful for adding more depth for water-based levels. The effect is not
		perfect but it often sounds convincing enough. This feature can be enabled/disabled with FEATURE_UNDERWATER. Underwater mode currently only affects FM volumes. It works by using the
		algorithm of the voice to read a value from the table (below), and adding part of it into slot operators (volume), and addint it fully to non-slot operators (modulator/sharpness).
		The table explains it below:
	</p>
	<table border="1">
		<tr><td>algorithm</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
		<tr><td>slot offset</td><td>$00</td><td>$00</td><td>$00</td><td>$00</td><td>$02</td><td>$06</td><td>$06</td><td>$07</td></tr>
		<tr><td>nonslot offs</td><td>$08</td><td>$08</td><td>$08</td><td>$08</td><td>$0A</td><td>$0E</td><td>$0E</td><td>$0F</td></tr>
	</table>
	<p>
		This can cause issues with some instruments, that do not sound good when this algorithm is applied. For underwater levels, you may have to consider how music and sound effects sound
		when underwater mode is enabled.
	</p>

	<h3 id="part6_3" class="bd">6.3 — Volume Fading</h3>
	<p>
		AMPS provides a custom and extensible way to create custom volume fades. By default, only a fade in and fade out are defined. AMPS uses a list of volumes to define how to do fades.
		Technically, a volume fade does not need to be limited to ending or starting at a muted volume, it can be fade from any volume to any other, and can use any values. The only things
		that matter is that there is a starting point, and it ends with a command. The table below explains what each command does:
	</p>
	<ul>
		<li><b>$80, fEnd</b> — Simply ends the volume fade.</li>
		<li><b>$84, fStop</b> — Stops the current song and sound effects immediately and ends the volume fade. Also clears sound driver memory and mutes hardware.</li>
		<li><b>$88, fResVol</b> — Resets master volume and asks channels to update their volume.</li>
		<li><b>$8C, fReset</b> — Does the same as both fStop and fResVol.</li>
	</ul>
	<p>
		Volume fading can be enabled programmatically from 68k by calling dLoadFade, where a4 is the volume fade data address. AMPS will automatically use the current FM volume and search
		the volume fade to find the closest spot to that. This helps make volume fades smooth and consistent, but it also makes it possible that your volume fade is cut short. Overall its
		not a good idea to rely on volume fades being consistent or taking certain amount of time, instead allowing it to take longer or shorter.
	</p>
	<p>
		Volume filters are read 3 values per frame. The format is FM volume, DAC volume, PSG volume. Instead, a command may be used as well. Channel volumes are added to music volumes and
		updated with the channel after volume changes (if the volume does not change, no update happens!). Any value $80 or above is treated as a command, as it is not a valid volume anyway.
		Updating DAC volume more often than once per 4 frames is not recommended because this will result in audible quality loss. Volume fades are processed before sound channels. A word of
		warning: If any volume fade data is located before ROM address $10000, the fading will never occur. This is simply a limitation with AMPS.
	</p>

	<h1 id="part7" class="bd">7 — Envelopes</h1>
	<p>
		AMPS has 2 types of envelopes: Modulation envelopes and volume envelopes. Volume envelopes can be enabled for only PSG channels, or all channels, using FEATURE_DACFMVOLENV.
		Modulation envelopes can be enabled or disabled using FEATURE_MODENV. These two assembly flags allow to choose which settings you will need, where them being disabled is faster and
		uses less RAM, but also allows for less features. The algorithm for both work very similarly, but modulation envelopes have an additional step. This will be mentioned later.
	</p>
	<p>
		Essentially, the algorithm simply looks for the next value in sequence every frame. There are volumes/frequencies and commands, and each envelope must end on a command. When a value
		is read from the volume envelope, if its between $00 and $7F, or $8C to $FF. Negative values apply a negative offset to volume or frequency. Values read from the envelope data
		signify the end of the envelope processing for the frame. The next byte is read next frame, and the current byte is used to calculate output volume or frequency offset. In case of
		volume envelopes, it is simply added to channel volume for the current frame (result is not saved), and modulation envelopes are slightly more complex. For modulation envelopes, the
		modulation sensitivity is used to multiply the read value. A sensitivity of $04 with read value of $07 results in offset of $23. Since the sensitivity read used is actually from $01
		to $100 instead of $00 to $FF. This can be set with a separate command. Below is the list of commands available:
	</p>
	<ul>
		<li><b>$80, eReset</b> — Restart to the start of the volume envelope. Continues execution from the beginning.</li>
		<li><b>$82, eHold</b> — Holds the volume or frequency offset at the last read value. Technically, the position is always decremented and value is read again.</li>
		<li><b>$84, eLoop x</b> — Set offset in volume envelope data to x. A value of 0 is equivalent to eReset. Continues execution from the loop point.</li>
		<li><b>$86, eStop</b> — Note off the channel and stop envelope processing.</li>
		<li><b>$88, esSens x</b> — Sets the modulation envelope sensitivity to x. Only valid for modulation envelopes! Continues execution afterwards.</li>
		<li><b>$8A, eaSens x</b> — Adds x to the modulation envelope sensitivity. Only valid for modulation envelopes! Continues execution afterwards.</li>
	</ul>
	<p>
		Some commands stop processing the envelope processing while others continue afterwards. Envelopes are defined in code/Data.asm, in <b>VolEnvs</b> and <b>ModEnvs</b>. They define a
		list of envelopes and afterwards their data. You can look at examples in these lists. Volume envelopes get the <b>vd</b> prefix for the data and <b>v</b> prefix for the equate.
		Modulation envelopes get the <b>md</b> envelope for data and <b>m</b> prefix for equates. Special equates, <b>vNone</b> and <b>mNone</b> refer to non-existent envelopes, that just
		skip the envelope process entirely. They have no effect to volume or frequency.
	</p>

	<h1 id="part8" class="bd">8 — Communication Bytes</h1>
	<p>
		AMPS allows trackers to communicate with the game program using communications bytes. By default, 8 bytes are defined that are accessible to both read & write from
		the tracker. You can conditionally execute tracker code when checking the communications byte with a condition mode. Whenever condition is set to false, number of
		commands are skipped instead of executing them. This can be used to skip commands, for example jumping or changing voice, to split the single path into multiple paths.
		This could be used for all kinds of neat effects, dynamic songs, songs that have ending point as opposed to just fading out, things like this. It is entirely up to the
		programmer on how they decide to accomplish this. <a href="#part4_1">This earlier part also lists which commands will be skipped.</a>
	</p>
	<p>
		The 8 bytes can be acessed through mComm to mComm+7. The game program is free to manipulate these in any way and the programmer is responsible for deciding which
		communications bytes are used for what purpose. Communications bytes are not initialized to any specific value, so relying on them being, for example, 0 is not adviced.
		Communication bytes do not get reset ever with AMPS, so sharing them between songs, sound effects or other is possible. It is a good idea to reset all the communications
		bytes you intend to use for songs with tracker code. Here is an example of reading and writing to the communications flags:
	</p>
	<asm>	<opc>move.b</opc>	<equ>mComm</equ><math>+</math><val>3</val><opc>.w</opc>,<ea>d0</ea>					<cmt>; load 4th communications byte to d0</cmt>
	<opc>and.b</opc>	#<val>$07</val>,<ea>d0</ea>						<cmt>; clear some extra bits out</cmt>
	<opc>move.b</opc>	<ea>d0</ea>,<equ>mComm</equ><opc>.w</opc>					<cmt>; save as the 1st communications byte</cmt></asm>
	<p>
		Communications bytes can be extended up to 256 bytes if the programmer needs that, but you have to remember, only 16 are available using the sCond command. Additionally,
		sCondReg command can be used to read from pre-defined RAM addresses or channel offsets. dcCondRegTable contains the table of pointers that are used for reading with this
		command.
	</p>

	<h1 id="part9" class="bd">9 — Memory Map</h1>
	<p>
		Below is the memory map for every individual channel and the entire sound driver. You can select various modes depending on which flags you have enabled, and the correct sequence is
		computed for you. This memory map is merely for reference purposes and you should never use the offsets provided here for actual work. The equates exist to make portability and
		consistency in mind and therefore are highly recommended to be used at all times.
	</p>
	<cbox><input type="checkbox" onclick="refRAM()" title="mdsafe" id="mdsafe" checked /><span>safe mode</span></cbox>
	<cbox><input type="checkbox" onclick="refRAM()" title="mdmod" id="mdmod" checked /><span>FEATURE_MODULATION</span></cbox>
	<cbox><input type="checkbox" onclick="refRAM()" title="mdport" id="mdport" /><span>FEATURE_PORTAMENTO</span></cbox>
	<cbox><input type="checkbox" onclick="refRAM()" title="mdmenv" id="mdmenv" /><span>FEATURE_MODENV</span></cbox>
	<cbox><input type="checkbox" onclick="refRAM()" title="mdvenvdf" id="mdvenvdf" /><span>FEATURE_DACFMVOLENV</span></cbox>
	<cbox><input type="checkbox" onclick="refRAM()" title="mdbackup" id="mdbackup" checked /><span>FEATURE_BACKUP</span></cbox>
	<cbox><input type="checkbox" onclick="refRAM()" title="mdfm6" id="mdfm6" checked /><span>FEATURE_FM6</span></cbox>
	<br/>
	<div style="width: 100%; display: flex; flex-direction: row">
		<div style="flex: 1 1"><h3>Global</h3><table border="1" id="ramtable"></table></div>
		<div style="flex: 1 1"><h3>Channel</h3><table border="1" id="chantable"></table></div>
	</div>
	<br/>

	<h1 id="part10" class="bd">10 — Creating Custom Music</h1>

	<h1 id="part11" class="bd">11 — Porting Music</h1>

	<h1 id="part12" class="bd">12 — Installing AMPS</h1>

	<h1 id="part13" class="bd">13 — Frequent Questions & Answers</h1>
	<h3>Do you have a Discord server?</h3>
	<p>
		We do indeed! If you want to get the latest AMPS news, talk to the developers, ask questions and get help, and get the latest news and exclusive updates!
		We also host other related projects under the same server. <a href="https://discord.gg/nW3CFaU">Join here</a>.
	</p>
	<h3>Where should I report bugs?</h3>
	<p>
		Preferably, you should submit an issue to the Github page of the project. However, you can also report them on our Discord or by directly messaging Natsumi on SSRG, Retro, or Discord.
	</p>
	<h3>I have a good idea! But how should I ask for it to get implemented?</h3>
	<p>
		Similarly to reporting bugs, you can in the same way also do feature requests or other improvements. There is no guarantee your feature request will get implemented but it will be considered
		for a future version.
	</p>
	<h3>Why is there no installation tutorial for my preferred disassembly?</h3>
	<p>
		It would be impossible to make tutorials for every single possible disassembly. Instead, there are pre-made disassemblies available for many common setups. IT is adviced to follow the
		commits for these disassemblies to port the sound driver to your specific setup. If no pre-made disassembly exists for your setup, you may request for it to be created by messaging Natsumi.
	</p>
	<h3>How often is AMPS updated?</h3>
	<p>
		It depends entirely on the changes being made and my personal time available. There is no set timeline for updates. The Github repositories will udate more often and a release will only be
		made when there is something stable to show.
	</p>
	<h3>Can I edit AMPS and use it for my project?</h3>
	<p>
		Yes, AMPS is open source and anyone can edit it to their liking. The source code is made to be as easy to modify as possible while still being optimal. You are free to use AMPS for
		any project as well. Although AMPS is open source and free to use for commercial purposes, because it is technically based on SMPS, which is property of SEGA, it may not be a good idea
		to use for commercial purposes.
	</p>
</body>
</html>
